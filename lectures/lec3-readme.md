# Полный конспект лекции 3: Углубленный JavaScript (слайды 1–30)

Эта лекция продолжает изучение JavaScript, фокусируясь на продвинутых возможностях функций, замыканиях, лексическом окружении, декораторах и привязке контекста. Каждая концепция критически важна для понимания внутренней работы языка и написания эффективного, поддерживаемого кода.[1]

***

## Слайд 1: Титульный слайд — Лекция 3

**Лекция 3. Углубленный JavaScript** — третье занятие курса, посвященное продвинутым темам языка: функциональному программированию, замыканиям, прототипам, классам и модулям. Эта лекция поднимает уровень понимания с базового синтаксиса до архитектурных паттернов и внутренних механизмов JavaScript.[1]

---

## Слайд 2: Продвинутая работа с функциями

Раздел охватывает современные возможности работы с функциями в JavaScript: rest/spread операторы, arguments, замыкания, лексическое окружение и декораторы. Эти инструменты позволяют писать гибкий, выразительный код и понимать, как JavaScript управляет областью видимости и контекстом выполнения.[1]

***

## Слайд 3: rest-оператор — проблема

Представьте задачу: нужно написать функцию `sumAll`, которая складывает **все** переданные числа, но заранее неизвестно, сколько аргументов будет.[1]

```javascript
function sumAll(a, b, c, d, e, f, ...) {
  // чиво ?
}
```

Стандартный синтаксис не позволяет указать переменное число параметров явно — нужен специальный механизм для сбора всех аргументов в одну коллекцию.[1]

---

## Слайд 4: rest-оператор — решение

**Rest-оператор** `...` собирает все оставшиеся аргументы функции в массив.[1]

```javascript
function sumAll(...args) { // args – имя массива
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}
```

**Построчно:**

- **Строка 1:** `...args` — rest-оператор собирает все переданные аргументы в массив с именем `args`.[1]
- **Строка 2:** Инициализируем переменную `sum` нулем для накопления суммы.
- **Строка 4:** Цикл `for...of` проходит по каждому элементу массива `args`.[1]
- **Строка 6:** Возвращаем итоговую сумму.

**Пример использования:**
```javascript
sumAll(1, 2, 3);       // 6
sumAll(10, 20, 30, 40); // 100
```

Rest-параметр должен быть последним в списке параметров функции и собирает все "оставшиеся" аргументы.[1]

***

## Слайд 5: arguments — старый способ

До появления rest-оператора (ES6) в JavaScript существовал объект `arguments` — псевдомассив всех аргументов функции.[1]

```javascript
function sumAll() {
  let sum = 0;

  for (let arg of arguments) sum += arg;

  return sum;
}
```

**Отличия от rest:**

- `arguments` доступен во всех обычных функциях автоматически, без явного объявления.[1]
- Это **псевдомассив** (array-like), у него есть индексы и `length`, но нет методов массива (`map`, `filter`).[1]
- **Важно:** `arguments` отсутствует в стрелочных функциях.[1]

**Современная практика:** используйте rest-оператор вместо `arguments` для чистоты и читаемости кода.[1]

---

## Слайд 6: spread-оператор — проблема

Обратная задача: у вас есть массивы чисел, и нужно передать их элементы как отдельные аргументы в функцию. Например, `Math.max()` принимает отдельные числа, а не массив.[1]

```javascript
let arr = [1, 5, 3];
Math.max(arr); // NaN — не работает!
```

Как "развернуть" массив в список аргументов ?[1]

***

## Слайд 7: spread-оператор — решение

**Spread-оператор** `...` разворачивает массив/итерируемый объект в список аргументов.[1]

```javascript
const arr1 = [0, -2, 1, 5];
const arr2 = [100, 200, 300, -322];

console.log(Math.max(...arr1, ...arr2));
```

**Построчно:**

- **Строка 1:** Объявляем первый массив с числами.[1]
- **Строка 3:** Объявляем второй массив.[1]
- **Строка 5:** `...arr1` разворачивает первый массив в `0, -2, 1, 5`, а `...arr2` — второй в `100, 200, 300, -322`. `Math.max()` получает все числа как отдельные аргументы и возвращает максимальное — `300`.[1]

**Дополнительные применения spread:**

```javascript
// Копирование массива
let arr = [1, 2, 3];
let arrCopy = [...arr];

// Слияние массивов
let merged = [...arr1, ...arr2];

// Клонирование объекта (поверхностное)
let obj = {a: 1, b: 2};
let objCopy = {...obj};
```

Spread создает **поверхностные** копии, не копируя вложенные объекты по значению.[1]

***

## Слайд 8: Замыкание — первый пример

**Замыкание** — способность функции "запоминать" переменные из внешней области видимости, даже после завершения выполнения внешней функции.[1]

```javascript
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // что будет показано: "John" или "Pete"?
```

**Ответ:** `"Hi, Pete"`.[1]

**Объяснение:**
Функция `sayHi` обращается к переменной `name` в момент **вызова**, а не в момент объявления. К моменту вызова `name` уже изменился на `"Pete"`, поэтому выводится актуальное значение.[1]

---

## Слайд 9: Замыкание — второй пример

Более сложный случай с вложенными функциями:[1]

```javascript
function makeWorker() {
  let name = "Pete";

  return function() {
    alert(name);
  };
}

let name = "John";

// create a function
let work = makeWorker();

// call it
work(); // что будет показано? "Pete" (из места создания) или "John" (из места выполнения)
```

**Ответ:** `"Pete"`.[1]

**Объяснение:**
Функция, возвращаемая из `makeWorker`, **замыкается** на лексическое окружение места своего создания. Внутри `makeWorker` существует локальная переменная `name = "Pete"`, и вложенная функция "запоминает" ее. Глобальная переменная `name = "John"` игнорируется, так как поиск переменных идет сначала в собственном окружении, потом во внешнем (где `name = "Pete"`), и только потом в глобальном.[1]

---

## Слайд 10: Лексическое окружение — определение

**Лексическое окружение (Lexical Environment)** — внутренний скрытый объект, связанный с каждой выполняемой функцией, блоком кода или скриптом.[1]

Состоит из двух частей:[1]

1. **Environment Record** — объект, хранящий все локальные переменные как свойства, а также информацию вроде `this`.[1]
2. **Ссылка на внешнее лексическое окружение** — связь с окружением "снаружи" (родительской функции или глобального контекста).[1]

Эта структура формирует **цепочку областей видимости**, по которой JavaScript ищет переменные при обращении к ним.[1]

***

## Слайд 11: Лексическое окружение — визуализация

"Переменная" — это свойство объекта `Environment Record`. Получить или изменить переменную означает получить или изменить свойство этого объекта.[1]

**Визуальная схема:**

```
┌─────────────────────────────┐
│ Environment Record          │
│  (хранилище переменных)     │
│  phrase: "Hello"            │
│  say: function              │
└─────────────────────────────┘
         │
         ↓ outer (ссылка на внешнее окружение)
       null (глобальное окружение)
```

У глобального лексического окружения нет внешнего окружения, поэтому ссылка указывает на `null`.[1]

***

## Слайд 12: Лексическое окружение — итого

**Итого**:[1]

- **Переменная** — свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.[1]
- **Работа с переменными** — работа со свойствами этого объекта.[1]

Это объясняет, почему переменные существуют в определенных областях видимости и почему функции могут обращаться к переменным из внешних контекстов.[1]

***

## Слайд 13: Лексическое окружение — Function Declaration

**Function Declaration** инициализируется **полностью** в момент создания лексического окружения, еще до выполнения кода.[1]

```javascript
sayHi("John"); // работает!

function sayHi(name) {
  alert(`Hello, ${name}`);
}
```

Для верхнеуровневых функций это происходит, когда скрипт начинает выполнение. Поэтому Function Declaration можно вызывать до ее объявления в коде — это называется **hoisting** (поднятие).[1]

**Важно:** `let/const` переменные **не** поднимаются в полностью инициализированном виде, обращение к ним до объявления вызывает `ReferenceError`.[1]

***

## Слайд 14: Лексическое окружение — пример с глобальным окружением

```javascript
let phrase = "Hello";

function say(name) {
  alert(`${phrase}, ${name}`);
}

say("John"); // Hello, John
```

**Визуализация окружений:**

```
При вызове say("John"):

┌─────────────────────────────┐
│ say Environment Record       │
│  name: "John"               │
│  outer → глобальное         │
└─────────────────────────────┘
         │
         ↓
┌─────────────────────────────┐
│ Global Environment Record   │
│  phrase: "Hello"            │
│  say: function              │
│  outer → null               │
└─────────────────────────────┘
```

Функция `say` замыкается на глобальное лексическое окружение, а глобальное — на `null`. При обращении к `phrase` внутри `say`, JavaScript сначала ищет ее в локальном окружении (не находит), затем поднимается по цепочке `outer` в глобальное окружение и находит `phrase = "Hello"`.[1]

***

## Слайд 15: Лексическое окружение — вложенные функции

Что происходит с вложенными функциями ? Они создают дополнительные уровни в цепочке окружений.[1]

```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2
```

Вложенная функция "запоминает" окружение `makeCounter` с переменной `count`, и каждый вызов `counter()` обращается к одной и той же переменной `count`, увеличивая ее.[1]

***

## Слайд 16: Лексическое окружение — [[Environment]]

Все функции "при рождении" получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение **места их создания**.[1]

```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
alert(counter()); // [[Environment]] хранит ссылку на окружение makeCounter
```

Это механизм, благодаря которому функции "знают", где они были созданы, и могут обращаться к переменным внешней области видимости даже после завершения выполнения внешней функции.[1]

***

## Слайд 17: Лексическое окружение — где еще есть?

Лексическое окружение существует не только у функций, но и у **блоков кода** — `if`, циклов, блоков в фигурных скобках.[1]

---

## Слайд 18: Лексическое окружение — блок if

```javascript
let phrase = "Hello";

if (true) {
  let user = "John";
  alert(`${phrase}, ${user}`);
}

alert(user); // Error, no such variable!
```

**Объяснение:**

Переменная `user` объявлена с `let` внутри блока `if`, поэтому она существует только в лексическом окружении этого блока. За пределами блока обращение к `user` вызывает ошибку.[1]

***

## Слайд 19: Лексическое окружение — цикл for

```javascript
for (let i = 0; i < 10; i++) {
  // У каждой итерации цикла своё собственное лексическое окружение
  // {i: value}
}

alert(i); // Ошибка, нет такой переменной
```

**Важная особенность:** каждая итерация цикла `for` создает **свое собственное** лексическое окружение с переменной `i`. Это важно для замыканий в циклах:[1]

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Выведет: 0, 1, 2 (каждая функция замкнулась на свою переменную i)
```

Если использовать `var` вместо `let`, все замыкания будут ссылаться на одну переменную, и результат будет `3, 3, 3`.[1]

***

## Слайд 20: Лексическое окружение — блок в фигурных скобках

```javascript
{
  // сделать какую-нибудь работу с локальными переменными,
  // которые не должны быть видны снаружи

  let message = "Hello";

  alert(message); // Hello
}

alert(message); // Ошибка: переменная message не определена
```

Произвольный блок в фигурных скобках создает свое лексическое окружение, изолируя переменные от внешней области. Это полезно для предотвращения конфликтов имен и управления областью видимости в сложных скриптах.[1]

***

## Слайд 21: Лексическое окружение — var (старое поведение)

Но так было не всегда:[1]

```javascript
if (true) {
  var name = "Леха";
}

console.log(name); // выводит "Леха"
```

Переменная `var` **игнорирует** блочную область видимости и видна снаружи блока `if`. Это одно из основных отличий `var` от `let/const` и источник многих багов в старом коде.[1]

***

## Слайд 22: IIFE — Immediately-Invoked Function Expressions

**IIFE** (Immediately-Invoked Function Expression) — функция, которая вызывается сразу после объявления.[1]

```javascript
(function() {
  let message = "Hello";
  alert(message);
})();

alert(message); // Error: message is not defined
```

**Зачем это нужно?**
В старом коде (до появления `let/const`) IIFE использовались для создания изолированной области видимости, так как `var` не имел блочной области. Современный код использует блоки с `let/const` для той же цели.[1]

***

## Слайд 23: IIFE — варианты синтаксиса

Существует несколько способов записи IIFE:[1]

```javascript
// Вариант 1: скобки вокруг функции
(function() {
  alert("IIFE");
})();

// Вариант 2: скобки вокруг всего выражения
(function() {
  alert("IIFE");
}());

// Вариант 3: с восклицательным знаком
!function() {
  alert("IIFE");
}();

// Вариант 4: с плюсом
+function() {
  alert("IIFE");
}();
```

Все варианты делают одно и то же — превращают Function Declaration в Function Expression и сразу вызывают ее.[1]

***

## Слайд 24: Объявление переменных для дедушек — var vs let/const

Почему `var` ведет себя странно ? Два основных отличия `var` от `let/const`:[1]

1. **Переменные `var` не имеют блочной области видимости** — они ограничены минимум телом функции, а не блока.[1]
2. **Объявления переменных `var` поднимаются (hoisted)** в начало функции или скрипта.[1]

```javascript
function example() {
  console.log(x); // undefined (не ошибка!)
  var x = 10;
  console.log(x); // 10
}
```

JavaScript интерпретирует это как:

```javascript
function example() {
  var x; // объявление поднято наверх
  console.log(x); // undefined
  x = 10; // присваивание остается на месте
  console.log(x); // 10
}
```

С `let/const` обращение к переменной до объявления вызовет `ReferenceError` из-за "временной мертвой зоны" (TDZ).[1]

***

## Слайд 25: Объявление переменных для дедушек — hoisting

**Hoisting (поднятие)** — механизм JavaScript, при котором объявления переменных и функций перемещаются в начало их области видимости перед выполнением кода.[1]

```javascript
sayHi(); // работает

function sayHi() {
  alert("Hi");
}
```

Функция поднимается целиком, поэтому вызов до объявления работает.[1]

```javascript
console.log(x); // undefined
var x = 5;
```

Переменная `var` поднимается, но без инициализации.[1]

**Современная практика:** избегайте `var` и используйте `let/const` для предсказуемого поведения.[1]

***

## Слайд 26: Функция-обертка (декоратор) — кеширование

**Декоратор** — функция, которая оборачивает другую функцию и добавляет ей дополнительное поведение.[1]

Пример: кеширование результатов медленной функции:[1]

```javascript
function slow(x) {
  // здесь могут быть ресурсоёмкие вычисления
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {       // если кеш содержит x
      return cache.get(x);    // возвращаем из кеша
    }

    let result = func(x);     // иначе вызываем функцию

    cache.set(x, result);     // кешируем результат
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1) кешируем
alert("Again: " + slow(1)); // возвращаем из кеша

alert(slow(2)); // slow(2) кешируем
alert("Again: " + slow(2)); // возвращаем из кеша
```

**Построчно:**

- **Строки 7–20:** `cachingDecorator` принимает функцию, создает `Map` для кеша и возвращает новую функцию-обертку.[1]
- **Строка 11:** Проверяем, есть ли результат для `x` в кеше.[1]
- **Строка 12:** Если есть — возвращаем из кеша, функция `func` не вызывается.[1]
- **Строка 15:** Если нет — вызываем оригинальную функцию.[1]
- **Строка 17:** Сохраняем результат в кеш для будущих вызовов.[1]

Это демонстрирует паттерн мемоизации — оптимизацию через кеширование.[1]

***

## Слайд 27: Функция-обертка — проблема с методами

К сожалению, простой декоратор не работает с методами объектов.[1]

```javascript
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

worker.slow = cachingDecorator(worker.slow);

worker.slow(1); // Ошибка: Cannot read property 'someMethod' of undefined
```

**Причина:** при вызове обернутой функции теряется контекст `this`. Обертка вызывает `func(x)`, но не передает ей контекст объекта `worker`.[1]

***

## Слайд 28: Функция-обертка — потеря контекста

При вызове метода `this` — это объект перед точкой.[1]

```javascript
worker.slow(1); // this === worker
```

Но внутри обертки:

```javascript
let result = func(x); // вызов без контекста, this === undefined
```

Чтобы исправить это, нужно **явно привязать контекст**.[1]

***

## Слайд 29: Привязываем контекст — func.call()

Метод `func.call(context, arg1, arg2, ...)` вызывает функцию с явно указанным `this`.[1]

```javascript
function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: "John" };

// user становится this, "Hello" — первым аргументом
say.call(user, "Hello"); // John: Hello
```

**Исправление декоратора:**

```javascript
function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }

    let result = func.call(this, x); // передаем текущий this

    cache.set(x, result);
    return result;
  };
}
```

Теперь `this` передается в оригинальную функцию, и декоратор работает с методами объектов.[1]

***

## Слайд 30: Детально, что произошло

Пошаговое объяснение работы исправленного декоратора:[1]

1. После декорации `worker.slow` становится оберткой `function(x) { ... }`.[1]
2. При выполнении `worker.slow(2)` обертка получает `2` в качестве аргумента и `this = worker` (объект перед точкой).[1]
3. Внутри обертки, если результат не кеширован, вызывается `func.call(this, x)`, передавая текущий `this` (= `worker`) и аргумент (= `2`) в оригинальную функцию.[1]

Таким образом, контекст сохраняется, и метод работает корректно.[1]

