# Отчёт по лабораторной работе №5

## Тема: Современные средства взаимодействия с API — `fetch`, `Promise`, архитектурные принципы и клиентское хранение данных

---

## 1. Call Stack и Event Loop

### Определение и взаимосвязь

**Call Stack** — это стек вызовов функций, используемый JavaScript-движком для отслеживания текущего контекста выполнения. Поскольку JavaScript является однопоточным языком, в каждый момент времени может выполняться только одна функция — та, что находится на вершине стека.

**Event Loop** — это циклический механизм, координирующий выполнение кода, обработку событий и асинхронных операций. Он постоянно проверяет, пуст ли Call Stack, и при его опустошении перемещает задачи из очередей (callback queue, microtask queue) в стек для выполнения.

Эти два компонента **неразрывно связаны**: Call Stack управляет синхронным выполнением, а Event Loop обеспечивает асинхронное поведение, позволяя JavaScript быть неблокирующим.

### Типы задач и порядок обработки

Существует два типа асинхронных задач:

- **Macrotasks** (очередь задач): `setTimeout`, `setInterval`, I/O-события, сетевые запросы.
- **Microtasks** (очередь микрозадач): `Promise.then/catch`, `queueMicrotask`.

**Приоритет обработки**:

1. Выполняется весь синхронный код.
2. Event Loop полностью опустошает **очередь микрозадач**.
3. Выполняется **одна макрозадача**.
4. Снова опустошается очередь микрозадач — и так далее.

### Пример

```js
console.log('A');
setTimeout(() => console.log('B'), 0);
Promise.resolve().then(() => console.log('C'));
console.log('D');
```

**Вывод**:

```
A
D
C
B
```

Обоснование: синхронный код → микрозадача → макрозадача.

---

## 2. Promise

### Определение и назначение

`Promise` — это специальный объект JavaScript, представляющий результат асинхронной операции, которая может завершиться успешно (`fulfilled`) или с ошибкой (`rejected`). Он был введён для устранения «ада коллбэков» и стандартизации асинхронного кода.

### Где используется

- `fetch()` — возвращает `Promise<Response>`
- `async/await` — синтаксический сахар над `Promise`
- Работа с файлами, IndexedDB, геолокацией и другими асинхронными API

### Состояния и методы обработки

Promise имеет три состояния:

- **pending** — начальное состояние
- **fulfilled** — операция завершена успешно
- **rejected** — операция завершена с ошибкой

Обработка:

```js
promise
  .then(result => { /* успех */ })
  .catch(error => { /* ошибка */ })
  .finally(() => { /* всегда */ });
```

### Статические методы

| Метод               | Назначение                                                                                                               |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| `Promise.all()`        | Ждёт все промисы; при первой ошибке — отклоняет                                             |
| `Promise.allSettled()` | Ждёт все промисы; возвращает статус каждого                                                   |
| `Promise.race()`       | Возвращает результат первого завершённого промиса                                     |
| `Promise.any()`        | Возвращает первый**успешный** промис; при полном провале — `AggregateError` |

---

## 3. Fetch API

### Назначение

`fetch()` — это современный встроенный метод для выполнения HTTP-запросов. Он заменяет устаревший `XMLHttpRequest`, предоставляя более чистый, промис-ориентированный интерфейс.

### Основные параметры (`options`)

```js
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data),
  mode: 'cors',
  credentials: 'include',   // для отправки cookies
  cache: 'no-store'
})
```

### Особенности

- Не выбрасывает исключение при HTTP-ошибках (404, 500) — необходимо проверять `response.ok`.
- Для POST-запросов в VK API требуется указывать `Content-Type: application/x-www-form-urlencoded` и передавать тело через `URLSearchParams`.

---

## 4. Принципы проектирования: DRY, KISS, SOLID

### DRY (Don’t Repeat Yourself)

> Каждая логическая сущность должна иметь единственное представление в системе.

**Пример**:
Вынесение формирования URL-адресов VK API в отдельную функцию `buildVkUrl()` в `modules/urls.js`, вместо дублирования логики в каждом компоненте.

### KISS (Keep It Simple, Stupid)

> Простота предпочтительнее сложности.

**Пример**:
Использование простой функции-хелпера вместо создания класса `Ajax` для `fetch`.

## 5. Web Storage API

Вот расширенное объяснение применения принципов SOLID в контексте одностраничного веб-приложения (SPA) с компонентами `MainPage`, `UserPage`, и основным файлом `App.js`, включая конкретные примеры кода:

---

### **1. S — Single Responsibility Principle (Принцип единственной ответственности)**

> *Каждый класс/компонент должен иметь одну и только одну причину для изменения.*

**Пример:**

- `MainPage` отвечает **только** за рендеринг главной страницы и обработку её логики.
- `UserPage` отвечает **только** за отображение информации о пользователе.

```jsx
// MainPage.jsx
export const MainPage = () => {
  return <h1>Главная страница</h1>;
};

// UserPage.jsx
export const UserPage = ({ userId }) => {
  const user = useUser(userId); // только логика, связанная с пользователем
  return <div>Профиль: {user.name}</div>;
};
```

**Нарушение:** Если `MainPage` начал бы также управлять авторизацией, загрузкой данных пользователя и навигацией — это нарушило бы SRP.

---

### **2. O — Open/Closed Principle (Принцип открытости/закрытости)**

> *Классы должны быть открыты для расширения, но закрыты для модификации.*

**Пример:**
Добавление новой страницы (`SettingsPage`) не требует изменения `App.js`, если используется декларативная структура маршрутов (например, через объект конфигурации или динамический импорт).

```js
// routes.js
import { MainPage } from './pages/MainPage';
import { UserPage } from './pages/UserPage';
import { SettingsPage } from './pages/SettingsPage'; // ← добавили новую

export const routes = {
  '/': MainPage,
  '/user': UserPage,
  '/settings': SettingsPage,
};
```

```jsx
// App.js
import { routes } from './routes';

export const App = () => {
  const path = useCurrentPath(); // хук для получения URL
  const PageComponent = routes[path] || routes['/'];
  return <PageComponent />;
};
```

Теперь, чтобы добавить новую страницу, **достаточно добавить её в `routes.js`**, не трогая `App.js`.

---

### **3. L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**

> *Объекты в программе могут быть заменены их подтипами без изменения корректности работы программы.*

**Пример:** Все страницы должны иметь одинаковый интерфейс — например, быть React-компонентами, принимающими `props` и возвращающими JSX.

```jsx
// Допустим, у нас есть общий контракт:
// Компонент страницы = функция, возвращающая ReactNode

const AnyPage = (props) => { /* ... */ };
// Любая страница может быть использована вместо другой в App.js
```

Если бы `UserPage` требовал специфического API (например, `init()` и `destroy()`), а другие страницы — нет, то подстановка `UserPage` в общий рендерер сломала бы логику. Чтобы этого избежать, все страницы должны соответствовать единому интерфейсу.

---

### **4. I — Interface Segregation Principle (Принцип разделения интерфейса)**

> *Клиенты не должны зависеть от интерфейсов, которые они не используют.*

**Пример:**
Компоненты страниц не реализуют "всё на свете". `MainPage` не принимает `userId`, `UserPage` не принимает `themeSettings`, если это не нужно.

```jsx
// ❌ Плохо: универсальный компонент со всеми возможными props
const Page = ({ userId, theme, lang, mode, data, ... }) => { ... }

// ✅ Хорошо: каждый компонент получает только то, что ему нужно
const MainPage = ({ lang }) => { ... }
const UserPage = ({ userId }) => { ... }
```

Также можно использовать TypeScript или PropTypes для явного описания интерфейса:

```ts
interface UserPageProps {
  userId: string;
}

const UserPage: React.FC<UserPageProps> = ({ userId }) => { ... };
```

---

### **5. D — Dependency Inversion Principle (Принцип инверсии зависимостей)**

> *Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.
> Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.*

**Пример:**
Компоненты не используют "магические строки" вроде `'/api/v1/users'` напрямую, а зависят от конфигурации или сервисов.

```js
// consts.js (абстракция)
export const API_BASE = process.env.REACT_APP_API_BASE || '/api';

// services/userService.js
import { API_BASE } from '../consts';

export const fetchUser = (id) => fetch(`${API_BASE}/users/${id}`);
```

```jsx
// UserPage.jsx
import { fetchUser } from '../services/userService'; // ← зависит от сервиса, а не от URL

export const UserPage = ({ userId }) => {
  useEffect(() => { fetchUser(userId); }, [userId]);
  // ...
};
```

Если завтра API-эндпоинт изменится, **нужно изменить только `consts.js` или `userService.js`**, а не все компоненты.

---

### Заключение

Применение SOLID в фронтенд-разработке:

- Упрощает **поддержку** и **тестирование**.
- Повышает **гибкость** при добавлении новых функций.
- Уменьшает **связность** между компонентами.
- Делает код **предсказуемым** и **масштабируемым**.

Даже в небольших SPA соблюдение этих принципов окупается уже на этапе второго рефакторинга.

Web Storage предоставляет два механизма клиентского хранения данных:

### `localStorage`

- **Время жизни**: постоянное (до ручной очистки).
- **Область видимости**: все вкладки одного origin.
- **Методы**:
  ```js
  localStorage.setItem('key', 'value');
  localStorage.getItem('key');
  localStorage.removeItem('key');
  localStorage.clear();
  ```

### `sessionStorage`

- **Время жизни**: до закрытия вкладки.
- **Область видимости**: только текущая вкладка.
- **Методы**: идентичны `localStorage`.

### Сравнение

| Критерий                            | `localStorage`                           | `sessionStorage`                         |
| ------------------------------------------- | ------------------------------------------ | ------------------------------------------ |
| Жизненный цикл                 | Постоянный                       | До закрытия вкладки       |
| Доступ между вкладками  | Да                                       | Нет                                     |
| Типичное использование | Настройки, темы, токены | Временные данные формы |

> ⚠️ Оба хранилища работают **только со строками**. Для объектов требуется сериализация через `JSON.stringify()` / `JSON.parse()`.
