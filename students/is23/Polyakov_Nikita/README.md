# HTML и CSS

## HTML

### Структура документа

* `<!doctype html>` — сообщает браузеру, что документ использует HTML5 и включает стандартизированный режим отображения.
* `<html lang="ru">` — корневой элемент; атрибут `lang` помогает поисковым системам и вспомогательным технологиям правильно трактовать язык.
* `<head>` — содержит метаданные страницы (`<meta>`, `<title>`, `<link>`, `<script defer>`), которые не отображаются напрямую в документе.
* `<body>` — визуальное содержимое страницы: текст, изображения, формы и любые интерактивные элементы.

**Ключевые уточнения:**

* **`<!doctype html>`** — обязательная декларация, включающая режим полных стандартов (standards mode) для предсказуемого рендеринга.
* **`<html lang="ru">`** — указание языка важно для:
  * корректного произношения текста программами чтения с экрана,
  * автоматического перевода в браузерах,
  * выбора правильных глифов и правил переноса.
* **`<head>`** обычно включает:
  * `<meta charset="utf-8">` — для корректной интерпретации символов,
  * `<meta name="viewport" content="width=device-width, initial-scale=1">` — для адаптивности на мобильных устройствах,
  * `<title>` — заголовок вкладки и важный SEO-элемент,
  * ссылки на стили (`<link rel="stylesheet">`) и скрипты с атрибутами вроде `defer` или `type="module"`.
* **`<body>`** содержит всё, что видит пользователь: семантические теги (`<header>`, `<main>`, `<section>`, `<footer>`), интерактивные элементы, медиа и формы.

---

### Семантика и доступность

* Заголовки `<h1>`–`<h6>` формируют иерархию разделов; важно соблюдать порядок для смыслового дерева и SEO.
* Семантические области (`<header>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`, `<footer>`) помогают экранным читалкам и поисковикам понимать структуру.
* Альтернативные описания (`alt` у `<img>`, `<figcaption>`, `aria-label`) делают контент доступным.
* Landmark-роли и атрибуты `aria-*` уточняют назначение элементов, повышая доступность интерфейса.

---

### Формы и валидация

* `<form>` с атрибутами `action` и `method` формирует отправку данных; `autocomplete` и `novalidate` управляют поведением браузера.
* `<label for="id">` привязывает подпись к полю ввода, улучшая доступность и UX.
* Современные типы `<input type="email|tel|date|number|range|color">` дают встроенную валидацию и подходящую клавиатуру на мобильных устройствах.
* Атрибуты `required`, `min`, `max`, `pattern` задают правила проверки; событие `invalid` позволяет выводить собственные сообщения об ошибках.
* Группировка через `<fieldset>` и `<legend>` делает формы логичнее для пользователей и ассистивных технологий.

#### Атрибуты валидации:

* **`required`** — поле обязательно для заполнения.
* **`min` / `max`** — задают допустимый диапазон значений (для чисел, дат и т.п.).
* **`pattern`** — регулярное выражение для текстовых полей (`text`, `email`, `tel` и др.).

Эти атрибуты активируют  **нативную проверку браузера** : при попытке отправить форму с недопустимыми данными отправка блокируется, и отображается стандартное сообщение об ошибке.

#### Событие `invalid`:

* Срабатывает **в момент неудачной валидации** (до отправки).
* Позволяет **отменить стандартное поведение** и показать  **кастомное сообщение об ошибке** .
* Для использования:
  1. Вызвать `event.preventDefault()` в обработчике,
  2. Вывести своё уведомление (например, через DOM).

---

### Метаданные и SEO

* `<meta charset="utf-8">` и `<meta name="viewport" content="width=device-width, initial-scale=1">` — базовый минимум для корректного отображения.
* Описания (`<meta name="description">`), ключевые слова и Open Graph (`og:title`, `og:image`) улучшают предпросмотры и сниппеты.
* `<link rel="canonical">` и `<link rel="alternate" hreflang="...">` контролируют индексацию и локализацию.
* Фавиконки (`<link rel="icon">`, `apple-touch-icon`) и манифесты PWA (`<link rel="manifest">`) отвечают за отображение на устройствах.

---

### Медиа и графика

* `<picture>` с `<source>` и `srcset` подстраивает изображения под плотность пикселей и размер экрана.
* `<audio>` и `<video>` поддерживают субтитры через `<track kind="captions">`.
* `<svg>` используется для векторных иконок и сложной графики, поддерживает стилизацию через CSS.
* 

Кастомные анимации в CSS создаются с помощью **`@keyframes`** и свойства  **`animation`** . В отличие от `transition`, который анимирует только между двумя состояниями (например, обычное и `:hover`), `@keyframes` позволяет задавать **сложные, многоэтапные анимации** без взаимодействия пользователя.

| `animation-name`            | Название `@keyframes`                                                           |
| ----------------------------- | ----------------------------------------------------------------------------------------- |
|                               | Длительность (например,`1s`,`500ms`)                              |
| `animation-timing-function` | Кривая скорости (`ease`,`linear`,`cubic-bezier(...)`и др.)         |
| `animation-delay`           | Задержка перед стартом                                                |
| `animation-iteration-count` | Сколько раз повторить (`1`,`infinite`,`3`)                       |
| `animation-direction`       | Направление (`normal`,`reverse`,`alternate`,`alternate-reverse`)       |
| `animation-fill-mode`       | Поведение до/после анимации (`forwards`,`backwards`,`both`) |
| `animation-play-state`      | Пауза/воспроизведение (`paused`,`running`)                        |

---

## CSS

### Каскад, наследование и специфичность

* **Каскад** определяет порядок применения правил: источник → специфичность → порядок объявления.
* **Специфичность** считается по селекторам:
  inline-стили > ID > классы/атрибуты/псевдоклассы > теги/псевдоэлементы.
* Конфликты имён разрешаются порядком подключения, методологиями именования или `@layer`.
* **Наследование** передаёт стили от родителя к потомку (например, `color`, `font-family`), но не действует на все свойства — это важно учитывать при проектировании.

---

### Организация и масштабирование

* Методологии (БЭМ, ITCSS, SMACSS) и модульные подходы (CSS Modules, CSS-in-JS) помогают избегать коллизий и обеспечивают повторное использование.
* **Ресеты (`reset.css`) и нормалайзеры (`normalize.css`)** выравнивают стили разных браузеров.
* **Кастомные свойства (`--token`)** позволяют создавать дизайн-системы и темизацию; рекомендуется задавать дефолты через `var(--token, fallback)`.

#### Методологии и модульные подходы

* **БЭМ (Блок–Элемент–Модификатор)** — именование по принципу `блок__элемент_модификатор`; улучшает читаемость и изоляцию.
* **ITCSS** — слоистая архитектура: settings → tools → generic → elements → objects → components → utilities.
* **SMACSS** — категории: base, layout, module, state, theme.
* **CSS Modules** — локальная область видимости классов на уровне сборки (Webpack/Vite).
* **CSS-in-JS** (styled-components, Emotion) — стили в JavaScript с динамическими пропсами и автоматической изоляцией.

Все они направлены на  **масштабируемость, поддерживаемость и переиспользование** .

#### Ресеты и нормалайзеры

* **`reset.css`** (Эрик Мейер) — сбрасывает все стили «в ноль».
* **`normalize.css`** — выравнивает поведение между браузерами, сохраняя полезные дефолты (например, жирный шрифт у `<h1>`).

Выбор зависит от проекта: `normalize` чаще используется в современных интерфейсах, где важны семантика и доступность.

#### Кастомные свойства (CSS-переменные)

* Объявляются как `--token: value`, используются через `var(--token)`.
* Идеальны для:
  * **дизайн-систем** (цвета, отступы, радиусы, тени),
  * **темизации** (переключение тем через изменение переменных на `:root`),
  * **адаптивности** (переопределение в медиазапросах).

---

### Макеты и компоновка

* **Flexbox** решает задачи одноосного расположения: выравнивание, изменение порядка, адаптивные колонки.
* **Grid** строит двумерные сетки; функции `repeat()`, `minmax()`, `auto-fit`, `auto-fill` упрощают адаптивность.
* **Flow layout** , `display: inline-block`, `position` и `float` всё ещё полезны, но требуют аккуратного применения.

#### Flow Layout (Normal Flow)

Это стандартный способ размещения элементов в порядке их следования в HTML.

* **Блочные элементы** (`<div>`, `<p>`, `<h1>–<h6>`, `<section>` и др.):
  * Занимают всю доступную ширину,
  * Располагаются вертикально друг под другом,
  * Уважают `width`, `height`, `margin`, `padding`.
* **Строчные элементы** (`<span>`, `<a>`, `<strong>`, `<em>` и др.):
  * Располагаются горизонтально в строке,
  * Игнорируют `width` и `height`,
  * Вертикальные `margin`/`padding` не влияют на соседей.
* **Строчно-блочные элементы** (`display: inline-block`):
  * Располагаются в строке (как строчные),
  * Поддерживают `width`, `height`, `margin`, `padding` (как блочные).

#### Свойство `position`

Определяет способ позиционирования элемента и его взаимодействие с потоком документа.

* **`static`** — стандартное поведение; `top`/`right`/`bottom`/`left` не работают.
* **`relative`** — позиционируется относительно исходного положения.
* **`absolute`** — позиционируется относительно ближайшего позиционированного предка (не `static`).
* **`fixed`** — позиционируется относительно окна браузера; не прокручивается.
* **`sticky`** — ведёт себя как `relative`, но при прокрутке «прилипает» как `fixed`.

---

### Адаптивность и единицы измерения

* Медиа-запросы (`@media`) и контейнерные запросы (`@container`) подстраивают стили под размеры экрана или блока.
* Относительные единицы (`em`, `rem`, `vw`, `vh`) и функции `clamp()`, `min()`, `max()` помогают масштабировать типографику и отступы.
* Логические свойства (`margin-block`, `padding-inline`) упрощают поддержку языков с разным направлением письма.

#### Логические свойства

Позволяют задавать отступы и размеры **в зависимости от направления текста** (LTR, RTL, вертикальное письмо), а не от физических сторон.

* **Блочная ось (block axis)** — направление потока блоков (обычно сверху вниз).
* **Инлайновая ось (inline axis)** — направление строк текста (обычно слева направо или справа налево).

Примеры:

* `margin-block` — отступы вдоль блочной оси (аналог `margin-top`/`margin-bottom`).
* `padding-inline` — отступы вдоль инлайновой оси (аналог `padding-left`/`padding-right`).

#### Относительные единицы

* **`em`** — относительно `font-size` текущего элемента; может «накапливать» эффект при вложенности.
* **`rem`** — относительно `font-size` корневого элемента (`<html>`); по умолчанию 16px; предсказуем при любой вложенности.
* **`vw`** — 1% от ширины viewport; используется для адаптивной типографики и секций.
* **`vh`** — 1% от высоты viewport; удобен для полноэкранных блоков (`height: 100vh`).

#### Функции адаптивности

|             |                                                                                                                             |
| ----------- | --------------------------------------------------------------------------------------------------------------------------- |
| `min()`   | Ограничение**максимума** (ширина контейнера, размер изображения) |
| `max()`   | Обеспечение**минимума** (отступы, высота кнопок)                                |
| `clamp()` | Адаптивные значения с**двумя границами** (шрифты, интервалы, padding) |

---

### Цвет, фон и эффекты

* Цветовые модели: `rgb()`, `hsl()`, `lch()` (новые браузеры); альфа-канал через `/` (например, `rgb(255 0 0 / 0.5)`).
* Фоны: `background-image`, `linear-gradient()`, `radial-gradient()`, множественные слои, `background-clip`.
* Переходы (`transition`), анимации (`@keyframes`, `animation`), трансформации (`transform`) и фильтры (`filter`) добавляют динамику.
* Медиа-фичи вроде `prefers-reduced-motion` позволяют уважать пользовательские настройки.

|           |                                                                             |                                                                                |
| --------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| `rgb()` | Универсальна, хорошо поддерживается         | Менее интуитивна                                                |
| `hsl()` | Удобна для палитр и регулировки                  | Яркость может меняться при смене оттенка    |
| `lch()` | Интуитивна, воспринимаема, широкая гамма | Ограниченная поддержка в старых браузерах |

---

### Псевдоклассы и псевдоэлементы

* **Псевдоклассы** (`:hover`, `:focus-visible`, `:nth-child`, `:is()`, `:has()`) описывают состояния и положение в DOM.
* **Псевдоэлементы** (`::before`, `::after`, `::marker`, `::selection`) создают дополнительные декоративные и контентные элементы.

#### Псевдоклассы

Используются для стилизации в зависимости от состояния или позиции. Записываются через **одинарное двоеточие** (`:`).

Примеры:

* `:hover` — при наведении курсора.
* `:focus-visible` — при фокусе с клавиатуры (если нужен визуальный индикатор).
* `:nth-child(n)` — по порядковому номеру среди соседей.
* `:is(.header, .footer)` — упрощает запись сложных селекторов.
* `:has(> .child)` — «родительский» селектор: выбирает элемент, **содержащий** указанный потомок.

#### Псевдоэлементы

Создают  **виртуальные элементы** , не существующие в HTML. Записываются через **двойное двоеточие** (`::`).

Примеры:

* `::before` / `::after` — вставляют контент до/после содержимого (требуется `content`).
* `::marker` — стилизует маркеры списков.
* `::selection` — задаёт стиль выделенного текста.

---

### Свойство `display`

Определяет тип отображения элемента и его взаимодействие с потоком документа.

* **`block`** — занимает всю ширину, начинается с новой строки; поддерживает размеры и отступы.
* **`inline`** — располагается в строке; игнорирует `width`, `height`, вертикальные `margin`.
* **`inline-block`** — в строке, но поддерживает размеры и отступы.
* **`none`** — полностью удаляет элемент из потока (не отображается и не занимает места).
* **`flex`** — создаёт флекс-контейнер для одноосной компоновки.
* **`grid`** — создаёт двумерную сетку для сложных макетов.
* **`inline-flex` / `inline-grid`** — флекс/грид в строчном контексте.
* **`contents`** — элемент исчезает визуально, но его дети остаются в потоке.

---

### Свойство `transform`

Позволяет изменять положение, масштаб, поворот и наклон элемента  **без влияния на поток документа** .

#### Основные функции:

* **`translate(x, y)`** — сдвиг по осям.
* **`rotate(angle)`** — поворот вокруг точки (`transform-origin`).
* **`scale(sx, sy)`** — масштабирование (может быть отрицательным).
* **`skew(ax, ay)`** — наклон (редко используется).
* **3D-трансформации** (`translate3d`, `rotate3d`, `scale3d`) — требуют `perspective`.

#### Особенности:

* Не влияет на layout соседей.
* Аппаратно ускоряется (GPU) — идеален для плавных анимаций.
* Порядок функций в `transform` важен: применяются слева направо.
* Точка трансформации по умолчанию — центр элемента (`50% 50%`).

Начиная с современных браузеров (поддержка с 2022–2023 гг.), появилось **отдельное CSS-свойство** под названием [`translate` ](https://developer.mozilla.org/en-US/docs/Web/CSS/translate), которое  **не требует использования `transform`** .

---

### Свойство `transition` в CSS позволяет **плавно анимировать изменения значений CSS-свойств** при смене состояния элемента (например, при наведении, фокусе, клике и т.д.).

* `transition-property` — какое свойство анимировать (`color`, `width`, `opacity` и т.д.)
* `transition-duration` — сколько времени длится анимация (в секундах или миллисекундах)
* `transition-timing-function` — как изменяется скорость анимации (`ease`, `linear`, `ease-in-out` и др.)
* `transition-delay` — задержка перед началом анимации

### Инструменты и отладка

* **DevTools** — исследование каскада, наследования, вычисленных стилей.
* **Линтеры** (stylelint) и **форматтеры** (Prettier) — повышают качество кода.
* **Типизация** (TypeScript + CSS-in-JS) — улучшает безопасность и автодополнение.
* **Автоматизация** (PostCSS, autoprefixer, сборщики вроде Vite/Webpack) — обеспечивает кроссбраузерность и ускоряет разработку.

---

## Прочее

* Официальные спецификации и руководства:  **MDN Web Docs** ,  **W3C** ,  **web.dev** .
