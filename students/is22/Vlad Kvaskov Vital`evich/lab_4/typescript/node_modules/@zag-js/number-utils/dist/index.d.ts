type Num$1<T extends string> = Record<T, number>;
declare function wrap(num: number, max: number): number;
declare function round(num: number, t?: number): string;
declare function roundToDevicePixel(num: number): number;
declare const valueToPercent: (v: number, r: Num$1<"step" | "min" | "max">) => number;
declare const percentToValue: (v: number, r: Num$1<"min" | "max">) => number;
declare function clamp(v: number, o: Num$1<"min" | "max">): number;
declare function countDecimals(value: number): number;
declare const increment: (v: number, s: number) => number;
declare const decrement: (v: number, s: number) => number;
declare function snapToStep(num: number, step: number): string;
declare function nan(v: number): number;
type FormatDecimalOptions = {
    /**
     * The minimum number of fraction digits to use. Possible values are from 0 to 20
     */
    minFractionDigits?: number;
    /**
     * The maximum number of fraction digits to use. Possible values are from 0 to 20;
     */
    maxFractionDigits?: number;
};
declare function formatDecimal(v: number, o: Omit<FormatDecimalOptions, "value">): string;
declare function isAtMax(val: number, o: Num$1<"max">): boolean;
declare function isAtMin(val: number, o: Num$1<"min">): boolean;
declare function isWithinRange(val: number, o: Num$1<"min" | "max">): boolean;

type Num<T extends string> = Record<T, number>;
declare const transform: (a: [number, number], b: [number, number]) => (v: number) => number;
declare function toRanges(o: Num<"min" | "max"> & {
    value: number[];
    spacing: number;
}): {
    min: number;
    max: number;
    value: number;
}[];
declare function toRangeArray(o: Num<"min" | "max" | "step">): number[];

export { type FormatDecimalOptions, type Num$1 as Num, clamp, countDecimals, decrement, formatDecimal, increment, isAtMax, isAtMin, isWithinRange, nan, percentToValue, round, roundToDevicePixel, snapToStep, toRangeArray, toRanges, transform, valueToPercent, wrap };
