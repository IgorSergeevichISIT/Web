"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  clamp: () => clamp,
  countDecimals: () => countDecimals,
  decrement: () => decrement,
  formatDecimal: () => formatDecimal,
  increment: () => increment,
  isAtMax: () => isAtMax,
  isAtMin: () => isAtMin,
  isWithinRange: () => isWithinRange,
  nan: () => nan,
  percentToValue: () => percentToValue,
  round: () => round,
  roundToDevicePixel: () => roundToDevicePixel,
  snapToStep: () => snapToStep,
  toRangeArray: () => toRangeArray,
  toRanges: () => toRanges,
  transform: () => transform,
  valueToPercent: () => valueToPercent,
  wrap: () => wrap
});
module.exports = __toCommonJS(src_exports);

// src/number.ts
function wrap(num, max) {
  return (num % max + max) % max;
}
function round(num, t) {
  const p = 10 ** (t ?? 10);
  num = Math.round(num * p) / p;
  return t ? num.toFixed(t) : num.toString();
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number") return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
var valueToPercent = (v, r) => (nan(v) - r.min) * 100 / (r.max - r.min);
var percentToValue = (v, r) => r.min + (r.max - r.min) * nan(v);
function clamp(v, o) {
  return Math.min(Math.max(nan(v), o.min), o.max);
}
function countDecimals(value) {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
var increment = (v, s) => decimalOperation(nan(v), "+", s);
var decrement = (v, s) => decimalOperation(nan(v), "-", s);
function snapToStep(num, step) {
  const p = countDecimals(step);
  const v = Math.round(nan(num) / step) * step;
  return round(v, p);
}
function nan(v) {
  return Number.isNaN(v) ? 0 : v;
}
function formatDecimal(v, o) {
  return new Intl.NumberFormat("en-US", {
    useGrouping: false,
    style: "decimal",
    minimumFractionDigits: o.minFractionDigits,
    maximumFractionDigits: o.maxFractionDigits
  }).format(nan(v));
}
function isAtMax(val, o) {
  return nan(val) >= o.max;
}
function isAtMin(val, o) {
  return nan(val) <= o.min;
}
function isWithinRange(val, o) {
  return nan(val) >= o.min && nan(val) <= o.max;
}
function decimalOperation(a, op, b) {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
}

// src/number-format.ts
var nf = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });
function formatter(n) {
  return parseFloat(nf.format(n));
}

// src/transform.ts
var transform = (a, b) => {
  const i = { min: a[0], max: a[1] };
  const o = { min: b[0], max: b[1] };
  return (v) => {
    if (i.min === i.max || o.min === o.max) return o.min;
    const ratio = (o.max - o.min) / (i.max - i.min);
    return o.min + ratio * (v - i.min);
  };
};
function toRanges(o) {
  const spacing = o.spacing ?? 0;
  return o.value.map((v, i) => {
    const min = i === 0 ? o.min : o.value[i - 1] + spacing;
    const max = i === o.value.length - 1 ? o.max : o.value[i + 1] - spacing;
    return { min, max, value: v };
  });
}
function toRangeArray(o) {
  let i = o.min;
  const range = [];
  while (i <= o.max) {
    range.push(i);
    i = formatter(i + o.step);
  }
  return range;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  clamp,
  countDecimals,
  decrement,
  formatDecimal,
  increment,
  isAtMax,
  isAtMin,
  isWithinRange,
  nan,
  percentToValue,
  round,
  roundToDevicePixel,
  snapToStep,
  toRangeArray,
  toRanges,
  transform,
  valueToPercent,
  wrap
});
//# sourceMappingURL=index.js.map