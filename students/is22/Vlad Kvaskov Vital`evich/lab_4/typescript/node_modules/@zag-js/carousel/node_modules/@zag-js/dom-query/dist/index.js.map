{"version":3,"sources":["../src/index.ts","../src/attrs.ts","../src/constants.ts","../src/is.ts","../src/contains.ts","../src/env.ts","../src/data-url.ts","../src/platform.ts","../src/event.ts","../src/get-by-id.ts","../src/sanitize.ts","../src/get-by-text.ts","../src/get-by-typeahead.ts","../src/get-computed-style.ts","../src/get-parent-node.ts","../src/get-scroll-position.ts","../src/tabbable.ts","../src/initial-focus.ts","../src/is-editable-element.ts","../src/is-hidden-element.ts","../src/is-overflow-element.ts","../src/raf.ts","../src/observe-attributes.ts","../src/observe-children.ts","../src/overflow.ts","../src/proxy-tab-focus.ts","../src/query.ts","../src/scope.ts","../src/scroll-into-view.ts","../src/set.ts","../src/visually-hidden.ts","../src/wait-for.ts"],"sourcesContent":["export * from \"./attrs\"\nexport * from \"./constants\"\nexport * from \"./contains\"\nexport * from \"./data-url\"\nexport * from \"./env\"\nexport * from \"./event\"\nexport * from \"./get-by-id\"\nexport * from \"./get-by-text\"\nexport * from \"./get-by-typeahead\"\nexport * from \"./get-computed-style\"\nexport * from \"./get-parent-node\"\nexport * from \"./get-scroll-position\"\nexport * from \"./initial-focus\"\nexport * from \"./is\"\nexport * from \"./is-editable-element\"\nexport * from \"./is-hidden-element\"\nexport * from \"./is-overflow-element\"\nexport * from \"./observe-attributes\"\nexport * from \"./observe-children\"\nexport * from \"./overflow\"\nexport * from \"./platform\"\nexport * from \"./proxy-tab-focus\"\nexport * from \"./query\"\nexport * from \"./raf\"\nexport * from \"./scope\"\nexport * from \"./scroll-into-view\"\nexport * from \"./set\"\nexport * from \"./tabbable\"\nexport * from \"./visually-hidden\"\nexport * from \"./wait-for\"\n","import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n","export const MAX_Z_INDEX = 2147483647\n","export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => el != null && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  el != null && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n","import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n","import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n","import { getWindow } from \"./env\"\n\nexport type DataUrlType = \"image/png\" | \"image/jpeg\" | \"image/svg+xml\"\n\nexport interface DataUrlOptions {\n  type: DataUrlType\n  quality?: number\n}\n\nexport function getDataUrl(svg: SVGElement | undefined | null, opts: DataUrlOptions): Promise<string> {\n  const { type, quality = 0.92 } = opts\n\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\")\n\n  const win = getWindow(svg)\n  const doc = win.document\n\n  const serializer = new win.XMLSerializer()\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg)\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source)\n\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString)\n  }\n\n  const svgBounds = svg.getBoundingClientRect()\n  const dpr = win.devicePixelRatio || 1\n\n  const canvas = doc.createElement(\"canvas\")\n  const image = new win.Image()\n  image.src = svgString\n\n  canvas.width = svgBounds.width * dpr\n  canvas.height = svgBounds.height * dpr\n\n  const context = canvas.getContext(\"2d\")\n  context!.scale(dpr, dpr)\n\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context!.drawImage(image, 0, 0)\n      resolve(canvas.toDataURL(type, quality))\n    }\n  })\n}\n","export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/)\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n\nexport const isModKey = (event: Pick<KeyboardEvent, \"metaKey\" | \"ctrlKey\">) =>\n  isApple() ? event.metaKey : event.ctrlKey\n","import { contains } from \"./contains\"\nimport { isApple } from \"./platform\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nfunction getComposedPath(event: any): EventTarget[] | undefined {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.()\n}\n\nexport function getEventTarget<T extends EventTarget>(\n  event: Partial<Pick<UIEvent, \"target\" | \"composedPath\">>,\n): T | null {\n  const composedPath = getComposedPath(event)\n  return (composedPath?.[0] ?? event.target) as T | null\n}\n\nexport const isSelfTarget = (event: Partial<Pick<UIEvent, \"currentTarget\" | \"target\" | \"composedPath\">>) => {\n  return contains(event.currentTarget as Node, getEventTarget(event))\n}\n\nexport function isOpeningInNewTab(event: Pick<MouseEvent, \"currentTarget\" | \"metaKey\" | \"ctrlKey\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const isAppleDevice = isApple()\n  if (isAppleDevice && !event.metaKey) return false\n  if (!isAppleDevice && !event.ctrlKey) return false\n\n  const localName = element.localName\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isDownloadingEvent(event: Pick<MouseEvent, \"altKey\" | \"currentTarget\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const localName = element.localName\n  if (!event.altKey) return false\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isComposingEvent(event: any) {\n  return event.nativeEvent?.isComposing ?? event.isComposing\n}\n","export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n","export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n","import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n","import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n","import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n","import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n","import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n","const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nconst isFrame = (element: any): element is HTMLIFrameElement => isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nfunction isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\ntype IncludeContainerType = boolean | \"if-empty\"\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nconst focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n\n/**\n * Returns the focusable elements within the element\n */\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n\n/**\n * Whether this element is focusable\n */\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): [HTMLElement, HTMLElement] | [null, null] {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n","import { getTabbableEdges, getTabbables } from \"./tabbable\"\n\nexport interface InitialFocusOptions {\n  root: HTMLElement | null\n  getInitialEl?: () => HTMLElement | null\n  enabled?: boolean\n  filter?: (el: HTMLElement) => boolean\n}\n\nexport function getInitialFocus(options: InitialFocusOptions): HTMLElement | undefined {\n  const { root, getInitialEl, filter, enabled = true } = options\n\n  if (!enabled) return\n\n  let node: HTMLElement | null | undefined = null\n\n  node ||= typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl\n  node ||= root?.querySelector<HTMLElement>(\"[data-autofocus],[autofocus]\")\n\n  if (!node) {\n    const tabbables = getTabbables(root)\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0]\n  }\n\n  return node || root || undefined\n}\n\nexport function isValidTabEvent(event: Pick<KeyboardEvent, \"shiftKey\" | \"currentTarget\">): boolean {\n  const container = event.currentTarget as HTMLElement | null\n  if (!container) return false\n\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container)\n  const doc = container.ownerDocument || document\n\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false\n  if (!firstTabbable && !lastTabbable) return false\n\n  return true\n}\n","import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n","export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n","import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n","export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n","import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveAttributeOptions {\n  attributes: string[]\n  callback(record: MutationRecord): void\n  defer?: boolean\n}\n\nfunction observeAttributesImpl(node: MaybeElement, options: ObserveAttributeOptions) {\n  if (!node) return\n  const { attributes, callback: fn } = options\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n  return () => obs.disconnect()\n}\n\nexport function observeAttributes(nodeOrFn: NodeOrFn, options: ObserveAttributeOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeAttributesImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveChildrenOptions {\n  callback: MutationCallback\n  defer?: boolean\n}\n\nfunction observeChildrenImpl(node: MaybeElement, options: ObserveChildrenOptions) {\n  const { callback: fn } = options\n  if (!node) return\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n  return () => obs.disconnect()\n}\n\nexport function observeChildren(nodeOrFn: NodeOrFn, options: ObserveChildrenOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeChildrenImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n","import { raf } from \"./raf\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus)\n    } else {\n      elementToFocus.focus()\n    }\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n","import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const dom = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => dom.getRootNode(ctx).activeElement,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === dom.getActiveElement(ctx),\n    getById: <T extends Element = HTMLElement>(ctx: ScopeContext, id: string) =>\n      dom.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...dom, ...methods }\n}\n","import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n","const cleanups = new WeakMap<Element, Map<string, () => void>>()\n\nexport function set(element: Element, key: string, setup: () => () => void) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, new Map())\n  }\n\n  const elementCleanups = cleanups.get(element)!\n  const prevCleanup = elementCleanups.get(key)\n\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup())\n    return () => {\n      elementCleanups.get(key)?.()\n      elementCleanups.delete(key)\n    }\n  }\n\n  const cleanup = setup()\n\n  const nextCleanup = () => {\n    cleanup()\n    prevCleanup()\n    elementCleanups.delete(key)\n  }\n\n  elementCleanups.set(key, nextCleanup)\n\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup\n    if (!isCurrent) return\n    cleanup()\n    elementCleanups.set(key, prevCleanup)\n  }\n}\n\nexport function setAttribute(element: Element, attr: string, value: string) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr)\n    element.setAttribute(attr, value)\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr)\n      } else {\n        element.setAttribute(attr, previousValue)\n      }\n    }\n  }\n\n  return set(element, attr, setup)\n}\n\nexport function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]) {\n  const setup = () => {\n    const exists = property in element\n    const previousValue = element[property]\n    element[property] = value\n    return () => {\n      if (!exists) {\n        delete element[property]\n      } else {\n        element[property] = previousValue\n      }\n    }\n  }\n\n  return set(element, property, setup)\n}\n\nexport function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!element) return () => {}\n\n  const setup = () => {\n    const prevStyle = element.style.cssText\n    Object.assign(element.style, style)\n    return () => {\n      element.style.cssText = prevStyle\n    }\n  }\n\n  return set(element, \"style\", setup)\n}\n","export const visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\",\n} as const\n","import { isHTMLElement } from \"./is\"\n\ntype ElementGetter = () => Element | null\n\nconst fps = 1000 / 60\n\nexport function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void) {\n  const el = query()\n\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el)\n    return () => void 0\n  } else {\n    const timerId = setInterval(() => {\n      const el = query()\n      if (isHTMLElement(el) && el.isConnected) {\n        cb(el)\n        clearInterval(timerId)\n      }\n    }, fps)\n\n    return () => clearInterval(timerId)\n  }\n}\n\nexport function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void) {\n  const cleanups: VoidFunction[] = []\n\n  queries?.forEach((query) => {\n    const clean = waitForElement(query, cb)\n    cleanups.push(clean)\n  })\n\n  return () => {\n    cleanups.forEach((fn) => fn())\n  }\n}\n"],"mappings":"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","names":["el","query","query","isHTMLElement","set","raf","fn","cleanups","cleanups","cleanups","query","el","cleanups"]}