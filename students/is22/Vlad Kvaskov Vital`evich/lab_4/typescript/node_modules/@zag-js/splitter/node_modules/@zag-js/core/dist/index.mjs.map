{"version":3,"sources":["../src/index.ts","../../utilities/core/src/array.ts","../../utilities/core/src/functions.ts","../../utilities/core/src/guard.ts","../../utilities/core/src/object.ts","../../utilities/core/src/warning.ts","../src/deep-merge.ts","../src/utils.ts","../src/guard-utils.ts","../src/machine.ts","../src/create-proxy.ts","../src/delay-utils.ts","../src/transition-utils.ts","../src/merge-props.ts"],"sourcesContent":["export { proxy, ref, snapshot, subscribe, type Ref } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n","export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const uniq = <T>(v: T[]): T[] => Array.from(new Set(v))\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n","export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n","export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n","import { createSplitProps } from \"./split-props\"\n\nexport function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n\nexport function omit<T extends Record<string, any>>(obj: T, keys: string[]) {\n  return createSplitProps(keys)(obj)[1]\n}\n","export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n","import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n","import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n","import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n","import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  public get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  public _created = () => {\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      // @ts-expect-error - Fix this\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n\n  public getHydrationState(): S.StateInit<TContext, TState> {\n    const state = this.getState()\n    return {\n      value: state.value,\n      tags: state.tags,\n    }\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n\nexport const isMachine = (value: any): value is AnyMachine => {\n  return value instanceof Machine || value?.type === MachineType.Machine\n}\n","import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n","import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n","import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n","import { callAll, isString } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g\n\nconst serialize = (style: string): Record<string, string> => {\n  const res: Record<string, string> = {}\n  let match: RegExpExecArray | null\n  while ((match = CSS_REGEX.exec(style))) {\n    res[match[1]!] = match[2]!\n  }\n  return res\n}\n\nconst css = (\n  a: Record<string, string> | string | undefined,\n  b: Record<string, string> | string | undefined,\n): Record<string, string> | string => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`\n    a = serialize(a)\n  } else if (isString(b)) {\n    b = serialize(b)\n  }\n  return Object.assign({}, a ?? {}, b ?? {})\n}\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (key.startsWith(\"on\") && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key])\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n"],"mappings":"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","names":["proxy","ref","snapshot","subscribe","state","determineDelay","delay"]}