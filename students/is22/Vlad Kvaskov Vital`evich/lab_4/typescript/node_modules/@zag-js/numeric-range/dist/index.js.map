{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export function getMinValueAtIndex(index: number, values: number[], minValue: number) {\n  return index === 0 ? minValue : values[index - 1]\n}\n\nexport function getMaxValueAtIndex(index: number, values: number[], maxValue: number) {\n  return index === values.length - 1 ? maxValue : values[index + 1]\n}\n\nexport function isValueAtMax(value: number, maxValue: number) {\n  return value >= maxValue\n}\n\nexport function isValueAtMin(value: number, minValue: number) {\n  return value <= minValue\n}\n\nexport function isValueWithinRange(value: number, minValue: number, maxValue: number) {\n  return value >= minValue && value <= maxValue\n}\n\nexport function getRoundedValue(value: number, minValue: number, step: number) {\n  return Math.round((value - minValue) / step) * step + minValue\n}\n\nexport function clampValue(value: number, minValue: number, maxValue: number) {\n  return Math.min(Math.max(value, minValue), maxValue)\n}\n\nexport function getValuePercent(value: number, minValue: number, maxValue: number) {\n  return (value - minValue) / (maxValue - minValue)\n}\n\nexport function getPercentValue(percent: number, minValue: number, maxValue: number, step: number) {\n  const value = percent * (maxValue - minValue) + minValue\n  const roundedValue = getRoundedValue(value, minValue, step)\n  return clampValue(roundedValue, minValue, maxValue)\n}\n\nexport function roundToStepPrecision(value: number, step: number) {\n  let roundedValue = value\n  let stepString = step.toString()\n  let pointIndex = stepString.indexOf(\".\")\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0\n  if (precision > 0) {\n    let pow = Math.pow(10, precision)\n    roundedValue = Math.round(roundedValue * pow) / pow\n  }\n  return roundedValue\n}\n\nexport function snapValueToStep(value: number, min: number | undefined, max: number | undefined, step: number): number {\n  min = Number(min)\n  max = Number(max)\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step\n  let snappedValue = roundToStepPrecision(\n    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,\n    step,\n  )\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step\n  }\n\n  // correct floating point behavior by rounding to step precision\n  snappedValue = roundToStepPrecision(snappedValue, step)\n\n  return snappedValue\n}\n\nfunction setValueAtIndex<T>(values: T[], index: number, value: T) {\n  if (values[index] === value) return values\n  return [...values.slice(0, index), value, ...values.slice(index + 1)]\n}\n\ntype RangeContext = {\n  min: number\n  max: number\n  step: number\n  values: number[]\n}\n\nexport function getValueSetterAtIndex(index: number, ctx: RangeContext) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min)\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max)\n  let nextValues = ctx.values.slice()\n\n  return function setValue(value: number) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step)\n    nextValues = setValueAtIndex(nextValues, index, value)\n    nextValues[index] = nextValue\n    return nextValues\n  }\n}\n\nexport function getNextStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] + ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getPreviousStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] - ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getClosestValueIndex(values: number[], targetValue: number) {\n  let targetIndex = values.findIndex((value) => targetValue - value < 0)\n\n  // If the index is zero then the closetThumb is the first one\n  if (targetIndex === 0) {\n    return targetIndex\n  }\n\n  // If no index is found they've clicked past all the thumbs\n  if (targetIndex === -1) {\n    return values.length - 1\n  }\n\n  let valueBefore = values[targetIndex - 1]\n  let valueAfter = values[targetIndex]\n\n  // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1\n  }\n\n  return targetIndex\n}\n\nexport function getValueRanges(values: number[], minValue: number, maxValue: number, gap: number) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap\n    return { min, max, value }\n  })\n}\n\nexport function getValueTransformer(valueA: number[], valueB: number[]) {\n  const input = { min: valueA[0], max: valueA[1] }\n  const output = { min: valueB[0], max: valueB[1] }\n\n  return function getValue(value: number) {\n    if (input.min === input.max || output.min === output.max) return output.min\n    const ratio = (output.max - output.min) / (input.max - input.min)\n    return output.min + ratio * (value - input.min)\n  }\n}\n\nexport function toFixedNumber(value: number, digits = 0, base: number = 10): number {\n  const pow = Math.pow(base, digits)\n  return Math.round(value * pow) / pow\n}\n\nexport function mod(value: number, modulo: number) {\n  return ((value % modulo) + modulo) % modulo\n}\n"],"mappings":"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","names":[]}