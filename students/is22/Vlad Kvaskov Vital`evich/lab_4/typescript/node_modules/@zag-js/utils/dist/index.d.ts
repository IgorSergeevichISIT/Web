declare function toArray<T>(v: T | T[] | undefined | null): T[];
declare const fromLength: (length: number) => number[];
declare const first: <T>(v: T[]) => T | undefined;
declare const last: <T>(v: T[]) => T | undefined;
declare const isEmpty: <T>(v: T[]) => boolean;
declare const has: <T>(v: T[], t: any) => boolean;
declare const add: <T>(v: T[], ...items: T[]) => T[];
declare const remove: <T>(v: T[], item: T) => T[];
declare const removeAt: <T>(v: T[], i: number) => T[];
declare const uniq: <T>(v: T[]) => T[];
declare const addOrRemove: <T>(v: T[], item: T) => T[];
declare function clear<T>(v: T[]): T[];
type IndexOptions = {
    step?: number;
    loop?: boolean;
};
declare function nextIndex<T>(v: T[], idx: number, opts?: IndexOptions): number;
declare function next<T>(v: T[], idx: number, opts?: IndexOptions): T | undefined;
declare function prevIndex<T>(v: T[], idx: number, opts?: IndexOptions): number;
declare function prev<T>(v: T[], index: number, opts?: IndexOptions): T | undefined;
declare const chunk: <T>(v: T[], size: number) => T[][];

declare const isEqual: (a: any, b: any) => boolean;

type MaybeFunction<T> = T | (() => T);
type Nullable<T> = T | null | undefined;
declare const runIfFn: <T>(v: T | undefined, ...a: T extends (...a: any[]) => void ? Parameters<T> : never) => T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T>;
declare const cast: <T>(v: unknown) => T;
declare const noop: () => void;
declare const callAll: <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) => (...a: Parameters<T>) => void;
declare const uuid: () => string;
declare function match<V extends string | number = string, R = unknown>(key: V, record: Record<V, R | ((...args: any[]) => R)>, ...args: any[]): R;
declare const tryCatch: <R>(fn: () => R, fallback: () => R) => R;

declare const isDev: () => boolean;
declare const isArray: (v: any) => v is any[];
declare const isBoolean: (v: any) => v is boolean;
declare const isObject: (v: any) => v is Record<string, any>;
declare const isNumber: (v: any) => v is number;
declare const isString: (v: any) => v is string;
declare const isFunction: (v: any) => v is Function;
declare const isNull: (v: any) => v is null | undefined;
declare const hasProp: <T extends string>(obj: any, prop: T) => obj is Record<T, any>;

declare function compact<T extends Record<string, unknown> | undefined>(obj: T): T;
declare function json(value: any): any;
declare function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;
declare function omit<T extends Record<string, any>>(obj: T, keys: string[]): Omit<T, string | number>;

type Dict = Record<string, any>;
declare function splitProps<T extends Dict>(props: T, keys: (keyof T)[]): Dict[];
declare const createSplitProps: <T extends Dict>(keys: (keyof T)[]) => <Props extends T>(props: Props) => [T, Omit<Props, keyof T>];

declare function warn(m: string): void;
declare function warn(c: boolean, m: string): void;
declare function invariant(m: string): void;
declare function invariant(c: boolean, m: string): void;

export { type IndexOptions, type MaybeFunction, type Nullable, add, addOrRemove, callAll, cast, chunk, clear, compact, createSplitProps, first, fromLength, has, hasProp, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNull, isNumber, isObject, isString, json, last, match, next, nextIndex, noop, omit, pick, prev, prevIndex, remove, removeAt, runIfFn, splitProps, toArray, tryCatch, uniq, uuid, warn };
