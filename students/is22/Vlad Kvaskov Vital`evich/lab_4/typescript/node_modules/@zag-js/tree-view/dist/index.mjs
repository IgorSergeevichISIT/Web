// src/tree-view.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("tree-view").parts(
  "root",
  "label",
  "tree",
  "item",
  "itemIndicator",
  "itemText",
  "branch",
  "branchControl",
  "branchTrigger",
  "branchContent",
  "branchText",
  "branchIndicator"
);
var parts = anatomy.build();

// src/tree-view.connect.ts
import { getEventKey, isModifierKey } from "@zag-js/dom-event";
import { contains, dataAttr, getEventTarget, isComposingEvent, isEditableElement } from "@zag-js/dom-query";

// src/tree-view.dom.ts
import { createScope, getByTypeahead, isHTMLElement, isHiddenElement, query, queryAll } from "@zag-js/dom-query";
var dom = createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `tree-root:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `tree-label:${ctx.id}`,
  getTreeId: (ctx) => ctx.ids?.tree ?? `tree-tree:${ctx.id}`,
  getNodeId(node) {
    if (!isHTMLElement(node)) return null;
    return node.dataset.branch ?? node.dataset.item ?? null;
  },
  getNodeEl(ctx, id) {
    const node = dom.getItemEl(ctx, id) ?? dom.getBranchEl(ctx, id);
    if (node?.dataset.part === "branch") {
      return query(node, "[data-part=branch-control]");
    }
    return node;
  },
  getTreeEl(ctx) {
    return dom.getById(ctx, dom.getTreeId(ctx));
  },
  getBranchEl(ctx, id) {
    const selector = `[role=treeitem][data-branch="${id}"]`;
    return query(dom.getTreeEl(ctx), selector);
  },
  getItemEl(ctx, id) {
    const selector = `[role=treeitem][data-item="${id}"]`;
    return query(dom.getTreeEl(ctx), selector);
  },
  getBranchControlEl(ctx, id) {
    const selector = "[data-part=branch-control]";
    return query(dom.getBranchEl(ctx, id), selector);
  },
  getFocusedEl(ctx) {
    if (!ctx.focusedValue) return null;
    return dom.getById(ctx, ctx.focusedValue);
  },
  focusNode(node, options) {
    if (isHTMLElement(node)) node.focus(options);
  },
  getNodeDepth(node) {
    return node?.dataset.depth ? Number(node.dataset.depth) : -1;
  },
  getTreeWalker(ctx, opts) {
    const { skipHidden = true, root } = opts ?? {};
    const treeEl = root || dom.getTreeEl(ctx);
    if (!treeEl) throw new Error("Tree or branch root not found");
    const doc = dom.getDoc(ctx);
    return doc.createTreeWalker(treeEl, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (skipHidden && isHiddenElement(node)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (node.role === "treeitem" && node.dataset.part !== "branch") {
          return NodeFilter.FILTER_ACCEPT;
        }
        if (node.role === "button" && node.dataset.part === "branch-control") {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
  },
  getMatchingEl(ctx, key) {
    const walker = dom.getTreeWalker(ctx);
    const elements = [];
    let node = walker.firstChild();
    while (node) {
      if (isHTMLElement(node)) elements.push(node);
      node = walker.nextNode();
    }
    return getByTypeahead(elements, {
      state: ctx.typeaheadState,
      key,
      activeId: ctx.focusedValue,
      itemToId: (v) => dom.getNodeId(v) ?? v.id
    });
  },
  getTreeNodes(ctx, options = {}) {
    const walker = dom.getTreeWalker(ctx, options);
    const nodes = [];
    let node = walker.firstChild();
    while (node) {
      if (isHTMLElement(node)) {
        nodes.push(node);
      }
      node = walker.nextNode();
    }
    return nodes;
  },
  getBranchNodes(ctx, depth) {
    if (depth === -1) return [];
    return queryAll(dom.getTreeEl(ctx), `[role=treeitem][data-part=branch][data-depth="${depth}"]`);
  },
  getNodesInRange(nodes, startNode, endNode) {
    const nextSet = /* @__PURE__ */ new Set();
    nodes.forEach((node) => {
      const nodeId = dom.getNodeId(node);
      if (nodeId == null) return;
      if (node === startNode || node === endNode) {
        nextSet.add(nodeId);
        return;
      }
      const startPos = node.compareDocumentPosition(startNode);
      const endPos = node.compareDocumentPosition(endNode);
      if (startPos & Node.DOCUMENT_POSITION_FOLLOWING && endPos & Node.DOCUMENT_POSITION_PRECEDING) {
        nextSet.add(nodeId);
        return;
      }
      if (startPos & Node.DOCUMENT_POSITION_PRECEDING && endPos & Node.DOCUMENT_POSITION_FOLLOWING) {
        nextSet.add(nodeId);
        return;
      }
    });
    return Array.from(nextSet);
  }
});

// src/tree-view.connect.ts
function connect(state, send, normalize) {
  const expandedValue = Array.from(state.context.expandedValue);
  const selectedValue = Array.from(state.context.selectedValue);
  const isTypingAhead = state.context.isTypingAhead;
  const focusedValue = state.context.focusedValue;
  function getItemState(props) {
    return {
      value: props.value,
      disabled: Boolean(props.disabled),
      focused: focusedValue === props.value,
      selected: selectedValue.includes(props.value)
    };
  }
  function getBranchState(props) {
    return {
      value: props.value,
      disabled: Boolean(props.disabled),
      focused: focusedValue === props.value,
      expanded: expandedValue.includes(props.value),
      selected: selectedValue.includes(props.value)
    };
  }
  return {
    expandedValue,
    selectedValue,
    expand(value) {
      if (!value) {
        send({ type: "EXPANDED.ALL" });
        return;
      }
      const nextValue = new Set(expandedValue);
      value.forEach((id) => nextValue.add(id));
      send({ type: "EXPANDED.SET", value: nextValue, src: "expand" });
    },
    collapse(value) {
      if (!value) {
        send({ type: "EXPANDED.SET", value: /* @__PURE__ */ new Set([]), src: "collapseAll" });
        return;
      }
      const nextValue = new Set(expandedValue);
      value.forEach((id) => nextValue.delete(id));
      send({ type: "EXPANDED.SET", value: nextValue, src: "collapse" });
    },
    deselect(value) {
      if (!value) {
        send({ type: "SELECTED.SET", value: /* @__PURE__ */ new Set([]), src: "deselectAll" });
        return;
      }
      const nextValue = new Set(selectedValue);
      value.forEach((id) => nextValue.delete(id));
      send({ type: "SELECTED.SET", value: nextValue, src: "deselect" });
    },
    select(value) {
      if (!value) {
        send({ type: "SELECTED.ALL" });
        return;
      }
      const nextValue = new Set(selectedValue);
      value.forEach((id) => nextValue.add(id));
      send({ type: "SELECTED.SET", value: nextValue, src: "select" });
    },
    focusBranch(id) {
      dom.getBranchControlEl(state.context, id)?.focus();
    },
    focusItem(id) {
      dom.getItemEl(state.context, id)?.focus();
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        id: dom.getRootId(state.context),
        dir: state.context.dir
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        id: dom.getLabelId(state.context),
        dir: state.context.dir
      });
    },
    getTreeProps() {
      return normalize.element({
        ...parts.tree.attrs,
        id: dom.getTreeId(state.context),
        dir: state.context.dir,
        role: "tree",
        "aria-label": "Tree View",
        "aria-labelledby": dom.getLabelId(state.context),
        "aria-multiselectable": state.context.selectionMode === "multiple" || void 0,
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const target = getEventTarget(event);
          if (isEditableElement(target)) return;
          const node = target?.closest("[role=treeitem]");
          if (!node) return;
          const nodeId = dom.getNodeId(node);
          if (nodeId == null) {
            console.warn(`Node id not found for node`, node);
            return;
          }
          const isBranchNode = !!target?.dataset.branch;
          const keyMap = {
            ArrowDown(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "ITEM.ARROW_DOWN", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowUp(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "ITEM.ARROW_UP", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowLeft(event2) {
              if (isModifierKey(event2) || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH.ARROW_LEFT" : "ITEM.ARROW_LEFT", id: nodeId });
            },
            ArrowRight(event2) {
              if (!isBranchNode || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "BRANCH.ARROW_RIGHT", id: nodeId });
            },
            Home(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "ITEM.HOME", id: nodeId, shiftKey: event2.shiftKey });
            },
            End(event2) {
              if (isModifierKey(event2)) return;
              event2.preventDefault();
              send({ type: "ITEM.END", id: nodeId, shiftKey: event2.shiftKey });
            },
            Space(event2) {
              if (node.dataset.disabled) return;
              if (isTypingAhead) {
                send({ type: "TREE.TYPEAHEAD", key: event2.key });
              } else {
                keyMap.Enter?.(event2);
              }
            },
            Enter(event2) {
              if (node.dataset.disabled) return;
              const isLink = target?.closest("a[href]");
              if (!isLink) event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH.CLICK" : "ITEM.CLICK", id: nodeId, src: "keyboard" });
            },
            "*"(event2) {
              if (node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "EXPAND.SIBLINGS", id: nodeId });
            },
            a(event2) {
              if (!event2.metaKey || node.dataset.disabled) return;
              event2.preventDefault();
              send({ type: "SELECTED.ALL", preventScroll: true, moveFocus: true });
            }
          };
          const key = getEventKey(event, state.context);
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            return;
          }
          if (!state.context.typeahead) return;
          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);
          if (!isValidTypeahead) return;
          send({ type: "TREE.TYPEAHEAD", key: event.key, id: nodeId });
          event.preventDefault();
        },
        onBlur(event) {
          if (contains(event.currentTarget, event.relatedTarget)) return;
          send({ type: "TREE.BLUR" });
        }
      });
    },
    getItemState,
    getItemProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        ...parts.item.attrs,
        dir: state.context.dir,
        "data-ownedby": dom.getTreeId(state.context),
        "data-item": itemState.value,
        tabIndex: itemState.focused ? 0 : -1,
        "data-focus": dataAttr(itemState.focused),
        role: "treeitem",
        "aria-current": itemState.selected ? "true" : void 0,
        "aria-selected": itemState.disabled ? void 0 : itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "aria-disabled": itemState.disabled,
        "data-disabled": dataAttr(itemState.disabled),
        "aria-level": props.depth,
        "data-depth": props.depth,
        style: {
          "--depth": props.depth
        },
        onFocus(event) {
          event.stopPropagation();
          send({ type: "ITEM.FOCUS", id: itemState.value });
        },
        onClick(event) {
          if (itemState.disabled) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "ITEM.CLICK", id: itemState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
          const isLink = event.currentTarget.matches("a[href]");
          if (!isLink) event.preventDefault();
        }
      });
    },
    getItemTextProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        ...parts.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused)
      });
    },
    getItemIndicatorProps(props) {
      const itemState = getItemState(props);
      return normalize.element({
        ...parts.itemIndicator.attrs,
        "aria-hidden": true,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused),
        hidden: !itemState.selected
      });
    },
    getBranchState,
    getBranchProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branch.attrs,
        "data-depth": props.depth,
        dir: state.context.dir,
        "data-branch": branchState.value,
        role: "treeitem",
        "data-ownedby": dom.getTreeId(state.context),
        "aria-level": props.depth,
        "aria-selected": branchState.disabled ? void 0 : branchState.selected,
        "data-selected": dataAttr(branchState.selected),
        "aria-expanded": branchState.expanded,
        "data-state": branchState.expanded ? "open" : "closed",
        "aria-disabled": branchState.disabled,
        "data-disabled": dataAttr(branchState.disabled),
        style: {
          "--depth": props.depth
        }
      });
    },
    getBranchIndicatorProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branchIndicator.attrs,
        "aria-hidden": true,
        "data-state": branchState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(branchState.disabled),
        "data-selected": dataAttr(branchState.selected),
        "data-focus": dataAttr(branchState.focused)
      });
    },
    getBranchTriggerProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branchTrigger.attrs,
        role: "button",
        dir: state.context.dir,
        "data-disabled": dataAttr(branchState.disabled),
        "data-state": branchState.expanded ? "open" : "closed",
        onClick(event) {
          if (branchState.disabled) return;
          send({ type: "BRANCH_TOGGLE.CLICK", id: branchState.value });
          event.stopPropagation();
        }
      });
    },
    getBranchControlProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branchControl.attrs,
        role: "button",
        dir: state.context.dir,
        tabIndex: branchState.focused ? 0 : -1,
        "data-state": branchState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(branchState.disabled),
        "data-selected": dataAttr(branchState.selected),
        "data-branch": branchState.value,
        "data-depth": props.depth,
        onFocus(event) {
          send({ type: "ITEM.FOCUS", id: branchState.value });
          event.stopPropagation();
        },
        onClick(event) {
          if (branchState.disabled) return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "BRANCH.CLICK", id: branchState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
        }
      });
    },
    getBranchTextProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branchText.attrs,
        dir: state.context.dir,
        "data-branch": branchState.value,
        "data-disabled": dataAttr(branchState.disabled),
        "data-state": branchState.expanded ? "open" : "closed"
      });
    },
    getBranchContentProps(props) {
      const branchState = getBranchState(props);
      return normalize.element({
        ...parts.branchContent.attrs,
        role: "group",
        dir: state.context.dir,
        "data-branch": branchState.value,
        "data-state": branchState.expanded ? "open" : "closed",
        hidden: !branchState.expanded
      });
    }
  };
}

// src/tree-view.machine.ts
import { createMachine, guards } from "@zag-js/core";
import { getByTypeahead as getByTypeahead2, isHTMLElement as isHTMLElement2, observeChildren } from "@zag-js/dom-query";
import { compact } from "@zag-js/utils";
var { and } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tree-view",
      initial: "idle",
      context: {
        expandedValue: [],
        selectedValue: [],
        focusedValue: null,
        expandOnClick: true,
        selectionMode: "single",
        typeahead: true,
        ...ctx,
        typeaheadState: getByTypeahead2.defaultOptions
      },
      computed: {
        isMultipleSelection: (ctx2) => ctx2.selectionMode === "multiple"
      },
      on: {
        "EXPANDED.SET": {
          actions: ["setExpanded"]
        },
        "SELECTED.SET": {
          actions: ["setSelected"]
        },
        "SELECTED.ALL": [
          {
            guard: and("isMultipleSelection", "moveFocus"),
            actions: ["selectAllItems", "focusTreeLastItem"]
          },
          {
            guard: "isMultipleSelection",
            actions: ["selectAllItems"]
          }
        ],
        "EXPANDED.ALL": {
          actions: ["expandAllBranches"]
        }
      },
      activities: ["trackChildrenMutation"],
      entry: ["setFocusableNode"],
      states: {
        idle: {
          on: {
            "ITEM.FOCUS": {
              actions: ["setFocusedItem"]
            },
            "ITEM.ARROW_DOWN": [
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreeNextItem", "extendSelectionToNextItem"]
              },
              {
                actions: ["focusTreeNextItem"]
              }
            ],
            "ITEM.ARROW_UP": [
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreePrevItem", "extendSelectionToPrevItem"]
              },
              {
                actions: ["focusTreePrevItem"]
              }
            ],
            "ITEM.ARROW_LEFT": {
              actions: ["focusBranchControl"]
            },
            "BRANCH.ARROW_LEFT": [
              {
                guard: "isBranchExpanded",
                actions: ["collapseBranch"]
              },
              {
                actions: ["focusBranchControl"]
              }
            ],
            "BRANCH.ARROW_RIGHT": [
              {
                guard: and("isBranchFocused", "isBranchExpanded"),
                actions: ["focusBranchFirstItem"]
              },
              {
                actions: ["expandBranch"]
              }
            ],
            "EXPAND.SIBLINGS": {
              actions: ["expandSiblingBranches"]
            },
            "ITEM.HOME": [
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToFirstItem", "focusTreeFirstItem"]
              },
              {
                actions: ["focusTreeFirstItem"]
              }
            ],
            "ITEM.END": [
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToLastItem", "focusTreeLastItem"]
              },
              {
                actions: ["focusTreeLastItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and("isCtrlKey", "isMultipleSelection"),
                actions: ["addOrRemoveItemFromSelection"]
              },
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToItem"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "BRANCH.CLICK": [
              {
                guard: and("isCtrlKey", "isMultipleSelection"),
                actions: ["addOrRemoveItemFromSelection"]
              },
              {
                guard: and("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToItem"]
              },
              {
                guard: "openOnClick",
                actions: ["selectItem", "toggleBranch"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "BRANCH_TOGGLE.CLICK": {
              actions: ["toggleBranch"]
            },
            "TREE.TYPEAHEAD": {
              actions: ["focusMatchedItem"]
            },
            "TREE.BLUR": {
              actions: ["clearFocusedItem", "setFocusableNode"]
            }
          }
        }
      }
    },
    {
      guards: {
        isBranchFocused: (ctx2, evt) => ctx2.focusedValue === evt.id,
        isBranchExpanded: (ctx2, evt) => ctx2.expandedValue.includes(evt.id),
        isShiftKey: (_ctx, evt) => evt.shiftKey,
        isCtrlKey: (_ctx, evt) => evt.ctrlKey,
        hasSelectedItems: (ctx2) => ctx2.selectedValue.length > 0,
        isMultipleSelection: (ctx2) => ctx2.isMultipleSelection,
        moveFocus: (_ctx, evt) => !!evt.moveFocus,
        openOnClick: (ctx2) => !!ctx2.expandOnClick
      },
      activities: {
        trackChildrenMutation(ctx2, _evt, { send }) {
          const treeEl = dom.getTreeEl(ctx2);
          return observeChildren(treeEl, {
            callback(records) {
              const removedNodes = records.flatMap((r) => Array.from(r.removedNodes)).filter((node) => {
                if (!isHTMLElement2(node)) return false;
                return node.matches("[role=treeitem]") || node.matches("[role=group]");
              });
              if (!removedNodes.length) return;
              let elementToFocus = null;
              records.forEach((record) => {
                if (isHTMLElement2(record.nextSibling)) {
                  elementToFocus = record.nextSibling;
                } else if (isHTMLElement2(record.previousSibling)) {
                  elementToFocus = record.previousSibling;
                }
              });
              if (elementToFocus) {
                dom.focusNode(elementToFocus);
              }
              const removedIds = /* @__PURE__ */ new Set();
              removedNodes.forEach((node) => {
                const nodeId = dom.getNodeId(node);
                if (isHTMLElement2(node) && nodeId != null) {
                  removedIds.add(nodeId);
                }
              });
              const nextSet = new Set(ctx2.selectedValue);
              removedIds.forEach((id) => nextSet.delete(id));
              send({ type: "SELECTED.SET", value: removedIds });
            }
          });
        }
      },
      actions: {
        setFocusableNode(ctx2) {
          if (ctx2.focusedValue) return;
          if (ctx2.selectedValue.length > 0) {
            const firstSelectedId = Array.from(ctx2.selectedValue)[0];
            ctx2.focusedValue = firstSelectedId;
            return;
          }
          const walker = dom.getTreeWalker(ctx2);
          const firstItem = walker.firstChild();
          if (!isHTMLElement2(firstItem)) return;
          ctx2.focusedValue = dom.getNodeId(firstItem);
        },
        selectItem(ctx2, evt) {
          set.selected(ctx2, [evt.id]);
        },
        setFocusedItem(ctx2, evt) {
          set.focused(ctx2, evt.id);
        },
        clearFocusedItem(ctx2) {
          set.focused(ctx2, null);
        },
        clearSelectedItem(ctx2) {
          set.selected(ctx2, []);
        },
        toggleBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          if (nextSet.has(evt.id)) {
            nextSet.delete(evt.id);
          } else {
            nextSet.add(evt.id);
          }
          set.expanded(ctx2, Array.from(nextSet));
        },
        expandBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          nextSet.add(evt.id);
          set.expanded(ctx2, Array.from(nextSet));
        },
        collapseBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          nextSet.delete(evt.id);
          set.expanded(ctx2, Array.from(nextSet));
        },
        setExpanded(ctx2, evt) {
          set.expanded(ctx2, evt.value);
        },
        setSelected(ctx2, evt) {
          set.selected(ctx2, evt.value);
        },
        focusTreeFirstItem(ctx2) {
          const walker = dom.getTreeWalker(ctx2);
          dom.focusNode(walker.firstChild());
        },
        focusTreeLastItem(ctx2, evt) {
          const walker = dom.getTreeWalker(ctx2);
          dom.focusNode(walker.lastChild(), { preventScroll: evt.preventScroll });
        },
        focusBranchFirstItem(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const walker = dom.getTreeWalker(ctx2);
          walker.currentNode = focusedEl;
          dom.focusNode(walker.nextNode());
        },
        focusTreeNextItem(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const walker = dom.getTreeWalker(ctx2);
          if (ctx2.focusedValue) {
            walker.currentNode = focusedEl;
            const nextNode = walker.nextNode();
            dom.focusNode(nextNode);
          } else {
            dom.focusNode(walker.firstChild());
          }
        },
        focusTreePrevItem(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const walker = dom.getTreeWalker(ctx2);
          if (ctx2.focusedValue) {
            walker.currentNode = focusedEl;
            const prevNode = walker.previousNode();
            dom.focusNode(prevNode);
          } else {
            dom.focusNode(walker.lastChild());
          }
        },
        focusBranchControl(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const parentDepth = Number(focusedEl.dataset.depth) - 1;
          if (parentDepth < 0) return;
          const branchSelector = `[data-part=branch][data-depth="${parentDepth}"]`;
          const closestBranch = focusedEl.closest(branchSelector);
          const branchControl = closestBranch?.querySelector("[data-part=branch-control]");
          dom.focusNode(branchControl);
        },
        selectAllItems(ctx2) {
          const nextSet = /* @__PURE__ */ new Set();
          const walker = dom.getTreeWalker(ctx2);
          let node = walker.firstChild();
          while (node) {
            const nodeId = dom.getNodeId(node);
            if (isHTMLElement2(node) && nodeId != null) {
              nextSet.add(nodeId);
            }
            node = walker.nextNode();
          }
          set.selected(ctx2, Array.from(nextSet));
        },
        focusMatchedItem(ctx2, evt) {
          dom.focusNode(dom.getMatchingEl(ctx2, evt.key));
        },
        addOrRemoveItemFromSelection(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const nextSet = new Set(ctx2.selectedValue);
          const nodeId = dom.getNodeId(focusedEl);
          if (nodeId == null) return;
          if (nextSet.has(nodeId)) {
            nextSet.delete(nodeId);
          } else {
            nextSet.add(nodeId);
          }
          set.selected(ctx2, Array.from(nextSet));
        },
        expandAllBranches(ctx2) {
          const nextSet = /* @__PURE__ */ new Set();
          const walker = dom.getTreeWalker(ctx2, { skipHidden: false });
          while (walker.nextNode()) {
            const node = walker.currentNode;
            const nodeId = dom.getNodeId(node);
            if (isHTMLElement2(node) && node.dataset.part === "branch-control" && nodeId != null) {
              nextSet.add(nodeId);
            }
          }
          set.expanded(ctx2, Array.from(nextSet));
        },
        expandSiblingBranches(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          const nodes = dom.getBranchNodes(ctx2, dom.getNodeDepth(focusedEl));
          const nextSet = /* @__PURE__ */ new Set();
          nodes.forEach((node) => {
            const nodeId = dom.getNodeId(node);
            if (nodeId == null) return;
            nextSet.add(nodeId);
          });
          set.expanded(ctx2, Array.from(nextSet));
        },
        extendSelectionToItem(ctx2, evt) {
          const focusedEl = dom.getNodeEl(ctx2, evt.id);
          if (!focusedEl) return;
          const nodes = dom.getTreeNodes(ctx2);
          const selectedIds = Array.from(ctx2.selectedValue);
          const anchorEl = dom.getNodeEl(ctx2, selectedIds[0]) || nodes[0];
          const nextSet = dom.getNodesInRange(nodes, anchorEl, focusedEl);
          set.selected(ctx2, nextSet);
        },
        extendSelectionToNextItem(ctx2, evt) {
          const nodeId = evt.id;
          const currentNode = dom.getNodeEl(ctx2, nodeId);
          if (!currentNode) return;
          const walker = dom.getTreeWalker(ctx2);
          walker.currentNode = currentNode;
          const nextNode = walker.nextNode();
          dom.focusNode(nextNode);
          const selectedIds = new Set(ctx2.selectedValue);
          const nextNodeId = dom.getNodeId(nextNode);
          if (nextNodeId == null) return;
          if (selectedIds.has(nodeId) && selectedIds.has(nextNodeId)) {
            selectedIds.delete(nodeId);
          } else if (!selectedIds.has(nextNodeId)) {
            selectedIds.add(nextNodeId);
          }
          set.selected(ctx2, Array.from(selectedIds));
        },
        extendSelectionToPrevItem(ctx2, evt) {
          const nodeId = evt.id;
          const currentNode = dom.getNodeEl(ctx2, nodeId);
          if (!currentNode) return;
          const walker = dom.getTreeWalker(ctx2);
          walker.currentNode = currentNode;
          const prevNode = walker.previousNode();
          dom.focusNode(prevNode);
          const selectedIds = new Set(ctx2.selectedValue);
          const prevNodeId = dom.getNodeId(prevNode);
          if (prevNodeId == null) return;
          if (selectedIds.has(nodeId) && selectedIds.has(prevNodeId)) {
            selectedIds.delete(nodeId);
          } else if (!selectedIds.has(prevNodeId)) {
            selectedIds.add(prevNodeId);
          }
          set.selected(ctx2, Array.from(selectedIds));
        },
        extendSelectionToFirstItem(ctx2) {
          const nodes = dom.getTreeNodes(ctx2);
          const anchorEl = dom.getNodeEl(ctx2, [...ctx2.selectedValue][0]) || nodes[0];
          const focusedEl = nodes[0];
          const selectedIds = dom.getNodesInRange(nodes, anchorEl, focusedEl);
          set.selected(ctx2, selectedIds);
        },
        extendSelectionToLastItem(ctx2) {
          const nodes = dom.getTreeNodes(ctx2);
          const anchorEl = dom.getNodeEl(ctx2, [...ctx2.selectedValue][0]) || nodes[0];
          const focusedEl = nodes[nodes.length - 1];
          const selectedIds = dom.getNodesInRange(nodes, anchorEl, focusedEl);
          set.selected(ctx2, selectedIds);
        }
      }
    }
  );
}
var invoke = {
  focusChange(ctx) {
    ctx.onFocusChange?.({ focusedValue: ctx.focusedValue });
  },
  expandedChange(ctx) {
    ctx.onExpandedChange?.({
      expandedValue: Array.from(ctx.expandedValue),
      focusedValue: ctx.focusedValue
    });
  },
  selectionChange(ctx) {
    ctx.onSelectionChange?.({
      selectedValue: Array.from(ctx.selectedValue),
      focusedValue: ctx.focusedValue
    });
  }
};
var set = {
  selected(ctx, value) {
    ctx.selectedValue = value;
    invoke.selectionChange(ctx);
  },
  focused(ctx, value) {
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  },
  expanded(ctx, value) {
    ctx.expandedValue = value;
    invoke.expandedChange(ctx);
  }
};
export {
  anatomy,
  connect,
  machine
};
//# sourceMappingURL=index.mjs.map