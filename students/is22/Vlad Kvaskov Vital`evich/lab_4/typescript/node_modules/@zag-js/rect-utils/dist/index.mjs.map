{"version":3,"sources":["../src/affine-transform.ts","../src/align.ts","../src/clamp.ts","../src/rect.ts","../src/intersection.ts","../src/distance.ts","../src/closest.ts","../src/constrain.ts","../src/contains.ts","../src/equality.ts","../src/from-element.ts","../src/from-points.ts","../src/union.ts","../src/from-range.ts","../src/from-rotation.ts","../src/from-window.ts","../src/operations.ts","../src/polygon.ts","../src/compass.ts","../src/resize.ts"],"sourcesContent":["import type { Point } from \"./types\"\n\nexport class AffineTransform {\n  m00: number\n  m01: number\n  m02: number\n  m10: number\n  m11: number\n  m12: number\n\n  constructor([m00, m01, m02, m10, m11, m12]: Iterable<number> = [0, 0, 0, 0, 0, 0]) {\n    this.m00 = m00\n    this.m01 = m01\n    this.m02 = m02\n    this.m10 = m10\n    this.m11 = m11\n    this.m12 = m12\n  }\n\n  applyTo(point: Point): Point {\n    const { x, y } = point\n    const { m00, m01, m02, m10, m11, m12 } = this\n\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12,\n    }\n  }\n\n  prepend(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10, // m00\n      this.m00 * other.m01 + this.m01 * other.m11, // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02, // m02\n      this.m10 * other.m00 + this.m11 * other.m10, // m10\n      this.m10 * other.m01 + this.m11 * other.m11, // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12, // m12\n    ])\n  }\n\n  append(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10, // m00\n      other.m00 * this.m01 + other.m01 * this.m11, // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02, // m02\n      other.m10 * this.m00 + other.m11 * this.m10, // m10\n      other.m10 * this.m01 + other.m11 * this.m11, // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12, // m12\n    ])\n  }\n\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10\n  }\n\n  get isInvertible() {\n    const det = this.determinant\n\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0\n  }\n\n  invert() {\n    const det = this.determinant\n\n    return new AffineTransform([\n      this.m11 / det, // m00\n      -this.m01 / det, // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det, // m02\n      -this.m10 / det, // m10\n      this.m00 / det, // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det, // m12\n    ])\n  }\n\n  get array(): number[] {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1]\n  }\n\n  get float32Array(): Float32Array {\n    return new Float32Array(this.array)\n  }\n\n  // Static\n\n  static get identity(): AffineTransform {\n    return new AffineTransform([1, 0, 0, 0, 1, 0])\n  }\n\n  static rotate(theta: number, origin?: Point): AffineTransform {\n    const rotation = new AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0])\n\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return rotation\n  }\n\n  rotate: (typeof AffineTransform)[\"rotate\"] = (...args) => {\n    return this.prepend(AffineTransform.rotate(...args))\n  }\n\n  static scale(sx: number, sy: number = sx, origin: Point = { x: 0, y: 0 }): AffineTransform {\n    const scale = new AffineTransform([sx, 0, 0, 0, sy, 0])\n\n    if (origin.x !== 0 || origin.y !== 0) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        scale,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return scale\n  }\n\n  scale: (typeof AffineTransform)[\"scale\"] = (...args) => {\n    return this.prepend(AffineTransform.scale(...args))\n  }\n\n  static translate(tx: number, ty: number): AffineTransform {\n    return new AffineTransform([1, 0, tx, 0, 1, ty])\n  }\n\n  translate: (typeof AffineTransform)[\"translate\"] = (...args) => {\n    return this.prepend(AffineTransform.translate(...args))\n  }\n\n  static multiply(...[first, ...rest]: AffineTransform[]): AffineTransform {\n    if (!first) return AffineTransform.identity\n    return rest.reduce((result, item) => result.prepend(item), first)\n  }\n\n  get a() {\n    return this.m00\n  }\n\n  get b() {\n    return this.m10\n  }\n\n  get c() {\n    return this.m01\n  }\n\n  get d() {\n    return this.m11\n  }\n\n  get tx() {\n    return this.m02\n  }\n\n  get ty() {\n    return this.m12\n  }\n\n  get scaleComponents(): Point {\n    return { x: this.a, y: this.d }\n  }\n\n  get translationComponents(): Point {\n    return { x: this.tx, y: this.ty }\n  }\n\n  get skewComponents(): Point {\n    return { x: this.c, y: this.b }\n  }\n\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`\n  }\n}\n","import type { AlignOptions, HAlign, Rect, VAlign } from \"./types\"\n\nfunction hAlign(a: Rect, ref: Rect, h: HAlign): Rect {\n  let x = ref.minX\n  if (h === \"left-inside\") x = ref.minX\n  if (h === \"left-outside\") x = ref.minX - ref.width\n  if (h === \"right-inside\") x = ref.maxX - ref.width\n  if (h === \"right-outside\") x = ref.maxX\n  if (h === \"center\") x = ref.midX - ref.width / 2\n  return { ...a, x }\n}\n\nfunction vAlign(a: Rect, ref: Rect, v: VAlign): Rect {\n  let y = ref.minY\n  if (v === \"top-inside\") y = ref.minY\n  if (v === \"top-outside\") y = ref.minY - a.height\n  if (v === \"bottom-inside\") y = ref.maxY - a.height\n  if (v === \"bottom-outside\") y = ref.maxY\n  if (v === \"center\") y = ref.midY - a.height / 2\n  return { ...a, y }\n}\n\nexport function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect {\n  const { h, v } = options\n  return vAlign(hAlign(a, ref, h), ref, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nconst clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max)\n\nexport const clampPoint = (position: Point, size: Size, boundaryRect: RectInit) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width)\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height)\n  return { x, y }\n}\n\nconst defaultMinSize: Size = {\n  width: 0,\n  height: 0,\n}\n\nconst defaultMaxSize: Size = {\n  width: Infinity,\n  height: Infinity,\n}\n\nexport const clampSize = (size: Size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize!.width), maxSize!.width),\n    height: Math.min(Math.max(size.height, minSize!.height), maxSize!.height),\n  }\n}\n","import type { Point, Rect, RectEdge, RectInit } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Point\n * -----------------------------------------------------------------------------*/\n\nexport const createPoint = (x: number, y: number) => ({ x, y })\n\nexport const subtractPoints = (a: Point, b: Point) => createPoint(a.x - b.x, a.y - b.y)\nexport const addPoints = (a: Point, b: Point) => createPoint(a.x + b.x, a.y + b.y)\n\nexport function isPoint(v: any): v is Point {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\")\n}\n\n/* -----------------------------------------------------------------------------\n * Rect\n * -----------------------------------------------------------------------------*/\n\nexport function createRect(r: RectInit): Rect {\n  const { x, y, width, height } = r\n  const midX = x + width / 2\n  const midY = y + height / 2\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY),\n  }\n}\n\nexport function isRect(v: any): v is Rect {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\")\n}\n\nexport function getRectCenters(v: Rect) {\n  const top = createPoint(v.midX, v.minY)\n  const right = createPoint(v.maxX, v.midY)\n  const bottom = createPoint(v.midX, v.maxY)\n  const left = createPoint(v.minX, v.midY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectCorners(v: Rect) {\n  const top = createPoint(v.minX, v.minY)\n  const right = createPoint(v.maxX, v.minY)\n  const bottom = createPoint(v.maxX, v.maxY)\n  const left = createPoint(v.minX, v.maxY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectEdges(v: Rect) {\n  const c = getRectCorners(v)\n  const top: RectEdge = [c.top, c.right]\n  const right: RectEdge = [c.right, c.bottom]\n  const bottom: RectEdge = [c.left, c.bottom]\n  const left: RectEdge = [c.top, c.left]\n  return { top, right, bottom, left }\n}\n","import { createRect } from \"./rect\"\nimport type { Rect, RectSide } from \"./types\"\n\n/**\n * Checks if a Rect intersects another Rect\n */\nexport function intersects(a: Rect, b: Rect): boolean {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y\n}\n\n/**\n * Returns a new Rect that represents the intersection between two Rects\n */\nexport function intersection(a: Rect, b: Rect): Rect {\n  const x = Math.max(a.x, b.x)\n  const y = Math.max(a.y, b.y)\n  const x2 = Math.min(a.x + a.width, b.x + b.width)\n  const y2 = Math.min(a.y + a.height, b.y + b.height)\n  return createRect({ x, y, width: x2 - x, height: y2 - y })\n}\n\n/**\n * Returns whether two rects collide along each edge\n */\nexport function collisions(a: Rect, b: Rect): Record<RectSide, boolean> {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX,\n  }\n}\n","import { intersects } from \"./intersection\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport interface DistanceValue extends Point {\n  value: number\n}\n\nexport function distance(a: Point, b: Point = { x: 0, y: 0 }): number {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nexport function distanceFromPoint(r: Rect, p: Point): DistanceValue {\n  let x = 0\n  let y = 0\n\n  if (p.x < r.x) x = r.x - p.x\n  else if (p.x > r.maxX) x = p.x - r.maxX\n\n  if (p.y < r.y) y = r.y - p.y\n  else if (p.y > r.maxY) y = p.y - r.maxY\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceFromRect(a: Rect, b: Rect): DistanceValue {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 }\n  const left = a.x < b.x ? a : b\n  const right = b.x < a.x ? a : b\n  const upper = a.y < b.y ? a : b\n  const lower = b.y < a.y ? a : b\n  let x = left.x === right.x ? 0 : right.x - left.maxX\n  x = Math.max(0, x)\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY\n  y = Math.max(0, y)\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number> {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY,\n  }\n}\n","import { distance } from \"./distance\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport function closest(...pts: Point[]) {\n  return (a: Point): Point => {\n    const ds = pts.map((b) => distance(b, a))\n    const c = Math.min.apply(Math, ds)\n    return pts[ds.indexOf(c)]\n  }\n}\n\nexport function closestSideToRect(ref: Rect, r: Rect): RectSide {\n  if (r.maxX <= ref.minX) return \"left\"\n  if (r.minX >= ref.maxX) return \"right\"\n  if (r.maxY <= ref.minY) return \"top\"\n  if (r.minY >= ref.maxY) return \"bottom\"\n  return \"left\"\n}\n\nexport function closestSideToPoint(ref: Rect, p: Point): RectSide {\n  const { x, y } = p\n\n  const dl = x - ref.minX\n  const dr = ref.maxX - x\n  const dt = y - ref.minY\n  const db = ref.maxY - y\n\n  let closest = dl\n  let side: RectSide = \"left\"\n\n  if (dr < closest) {\n    closest = dr\n    side = \"right\"\n  }\n  if (dt < closest) {\n    closest = dt\n    side = \"top\"\n  }\n  if (db < closest) {\n    side = \"bottom\"\n  }\n\n  return side\n}\n","import type { RectInit } from \"./types\"\n\n// given a rect and a boundary, return a new rect that is constrained within the boundary\n// resize or reposition the rect so that it fits within the boundary\nexport const constrainRect = (rect: RectInit, boundary: RectInit): RectInit => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width))\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height))\n\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height),\n  }\n}\n","import { getRectCorners, isRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function containsPoint(r: Rect, p: Point): boolean {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY\n}\n\nexport function containsRect(a: Rect, b: Rect): boolean {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c))\n}\n\nexport function contains(r: Rect, v: Rect | Point): boolean {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v)\n}\n","import type { Point, RectInit, Size } from \"./types\"\n\nexport const isSizeEqual = (a: Size, b: Size) => {\n  return a.width === b.width && a.height === b.height\n}\n\nexport const isPointEqual = (a: Point, b: Point) => {\n  return a.x === b.x && a.y === b.y\n}\n\nexport const isRectEqual = (a: RectInit, b: RectInit) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b)\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nfunction getCacheComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n\nexport function getElementRect(el: HTMLElement, opts: ElementRectOptions = {}): Rect {\n  return createRect(getClientRect(el, opts))\n}\n\nexport type ElementRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n  /**\n   * Whether to exclude the element's borders from the calculation.\n   */\n  excludeBorders?: boolean\n}\n\nfunction getClientRect(el: HTMLElement, opts: ElementRectOptions = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts\n\n  const { x, y, width, height } = el.getBoundingClientRect()\n  const r = { x, y, width, height }\n\n  const style = getCacheComputedStyle(el)\n\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style\n\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth)\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth)\n\n  if (excludeBorders) {\n    r.width -= borderXWidth\n    r.height -= borderYWidth\n    r.x += px(borderLeftWidth)\n    r.y += px(borderTopWidth)\n  }\n\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth\n    r.width -= scrollbarWidth\n    r.height -= scrollbarHeight\n  }\n\n  return r\n}\n\nconst px = (v: string) => parseFloat(v.replace(\"px\", \"\"))\n\nconst sum = (...vals: string[]) => vals.reduce((sum, v) => sum + (v ? px(v) : 0), 0)\n","import { createRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function getRectFromPoints(...pts: Point[]): Rect {\n  const xs = pts.map((p) => p.x)\n  const ys = pts.map((p) => p.y)\n\n  const x = Math.min(...xs)\n  const y = Math.min(...ys)\n\n  const width = Math.max(...xs) - x\n  const height = Math.max(...ys) - y\n\n  return createRect({ x, y, width, height })\n}\n","import { getRectFromPoints } from \"./from-points\"\nimport type { Rect } from \"./types\"\n\nconst { min, max } = Math\n\nexport function union(...rs: Rect[]): Rect {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY)),\n  }\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY)),\n  }\n  return getRectFromPoints(pMin, pMax)\n}\n","import { createRect } from \"./rect\"\nimport { getElementRect } from \"./from-element\"\nimport { union } from \"./union\"\nimport type { Rect } from \"./types\"\n\nexport function fromRange(range: Range): Rect {\n  let rs: Rect[] = []\n  const rects = Array.from(range.getClientRects())\n\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect))\n    return union.apply(undefined, rs)\n  }\n\n  let start: Node | ParentNode | null = range.startContainer\n\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode\n  }\n\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start)\n    rs.push({ ...r, x: r.maxX, width: 0 })\n  }\n\n  return union.apply(undefined, rs)\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function toRad(d: number) {\n  return ((d % 360) * Math.PI) / 180\n}\n\nexport function rotate(a: Point, d: number, c: Point): Point {\n  const r = toRad(d)\n\n  const sin = Math.sin(r)\n  const cos = Math.cos(r)\n\n  const x = a.x - c.x\n  const y = a.y - c.y\n\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos,\n  }\n}\n\nexport function getRotationRect(r: Rect, deg: number): Rect {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center))\n\n  const xs = rr.map((p) => p.x)\n  const ys = rr.map((p) => p.y)\n\n  const minX = Math.min(...xs)\n  const minY = Math.min(...ys)\n\n  const maxX = Math.max(...xs)\n  const maxY = Math.max(...ys)\n\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  })\n}\n","import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nexport type WindowRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n}\n\n/**\n * Creates a rectange from window object\n */\nexport function getWindowRect(win: Window, opts: WindowRectOptions = {}): Rect {\n  return createRect(getViewportRect(win, opts))\n}\n\n/**\n * Get the rect of the window with the option to exclude the scrollbar\n */\nexport function getViewportRect(win: Window, opts: WindowRectOptions) {\n  const { excludeScrollbar = false } = opts\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win\n  const width = visualViewport?.width || innerWidth\n  const height = visualViewport?.height || innerHeight\n  const rect = { x: 0, y: 0, width, height }\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight\n    rect.width -= scrollbarWidth\n    rect.height -= scrollbarHeight\n  }\n  return rect\n}\n","import { createRect } from \"./rect\"\nimport type { Point, Rect, RectInset, SymmetricRectInset } from \"./types\"\n\nexport const isSymmetric = (v: any): v is SymmetricRectInset => \"dx\" in v || \"dy\" in v\n\nexport function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom,\n  })\n}\n\nexport function expand(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shrink(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shift(r: Rect, o: Partial<Point>): Rect {\n  const { x = 0, y = 0 } = o\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height,\n  })\n}\n","import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, RectInit } from \"./types\"\n\nexport function getElementPolygon(rectValue: RectInit, placement: string) {\n  const rect = createRect(rectValue)\n  const { top, right, left, bottom } = getRectCorners(rect)\n  const [base] = placement.split(\"-\")\n\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom],\n  }[base]\n}\n\nexport function isPointInPolygon(polygon: Point[], point: Point) {\n  const { x, y } = point\n  let c = false\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      c = !c\n    }\n  }\n  return c\n}\n\nfunction createPolygonElement() {\n  const id = \"debug-polygon\"\n  const existingPolygon = document.getElementById(id)\n  if (existingPolygon) {\n    return existingPolygon\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\",\n  })\n\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\")\n  polygon.setAttribute(\"id\", id)\n  polygon.setAttribute(\"points\", \"0,0 0,0\")\n  svg.appendChild(polygon)\n  document.body.appendChild(svg)\n  return polygon\n}\n\nexport function debugPolygon(polygon: Point[]) {\n  const el = createPolygonElement()\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \")\n  el.setAttribute(\"points\", points)\n  return () => {\n    el.remove()\n  }\n}\n","import type { Point } from \"./types\"\n\nexport type CompassDirection = \"n\" | \"ne\" | \"e\" | \"se\" | \"s\" | \"sw\" | \"w\" | \"nw\"\n\nexport const compassDirectionMap: Record<CompassDirection, Point> = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 },\n}\n\nexport const oppositeDirectionMap: Record<CompassDirection, CompassDirection> = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\",\n}\n","import { AffineTransform } from \"./affine-transform\"\nimport { compassDirectionMap, oppositeDirectionMap, type CompassDirection } from \"./compass\"\nimport type { Point, Rect, RectInit, ScalingOptions } from \"./types\"\n\nconst { sign, abs, min } = Math\n\nfunction getRectExtentPoint(rect: Rect, direction: CompassDirection) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY\n  return { x, y }\n}\n\nfunction getOppositeDirection(direction: CompassDirection) {\n  return oppositeDirectionMap[direction]\n}\n\nexport function resizeRect(rect: Rect, offset: Point, direction: CompassDirection, opts: ScalingOptions) {\n  const { scalingOriginMode, lockAspectRatio } = opts\n\n  const extent = getRectExtentPoint(rect, direction)\n\n  const oppositeDirection = getOppositeDirection(direction)\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection)\n\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 }\n  }\n\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y,\n  }\n\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1,\n  }\n\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y,\n  }\n\n  const scaleX = (multiplier.x * newSize.width) / rect.width\n  const scaleY = (multiplier.y * newSize.height) / rect.height\n\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY\n\n  const scale = lockAspectRatio\n    ? { x: largestMagnitude, y: largestMagnitude }\n    : {\n        x: extent.x === oppositeExtent.x ? 1 : scaleX,\n        y: extent.y === oppositeExtent.y ? 1 : scaleY,\n      }\n\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y)\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1\n  }\n\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x)\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1\n  }\n\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false)\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY,\n        }),\n        false,\n      )\n  }\n}\n\nfunction createRectFromPoints(initialPoint: Point, finalPoint: Point, normalized: boolean = true): RectInit {\n  if (normalized) {\n    return {\n      x: min(finalPoint.x, initialPoint.x),\n      y: min(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y),\n    }\n  }\n\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y,\n  }\n}\n\nfunction transformRect(rect: Rect, transform: AffineTransform, normalized = true): RectInit {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY })\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY })\n  return createRectFromPoints(p1, p2, normalized)\n}\n"],"mappings":";;;;;AAEO,IAAM,kBAAN,MAAM,iBAAgB;AAAA,EAQ3B,YAAY,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,IAAsB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG;AAPnF;AACA;AACA;AACA;AACA;AACA;AA8FA,kCAA6C,IAAI,SAAS;AACxD,aAAO,KAAK,QAAQ,iBAAgB,OAAO,GAAG,IAAI,CAAC;AAAA,IACrD;AAgBA,iCAA2C,IAAI,SAAS;AACtD,aAAO,KAAK,QAAQ,iBAAgB,MAAM,GAAG,IAAI,CAAC;AAAA,IACpD;AAMA,qCAAmD,IAAI,SAAS;AAC9D,aAAO,KAAK,QAAQ,iBAAgB,UAAU,GAAG,IAAI,CAAC;AAAA,IACxD;AAvHE,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK,MAAM;AACX,SAAK,MAAM;AAAA,EACb;AAAA,EAEA,QAAQ,OAAqB;AAC3B,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,UAAM,EAAE,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI,IAAI;AAEzC,WAAO;AAAA,MACL,GAAG,MAAM,IAAI,MAAM,IAAI;AAAA,MACvB,GAAG,MAAM,IAAI,MAAM,IAAI;AAAA,IACzB;AAAA,EACF;AAAA,EAEA,QAAQ,OAAyC;AAC/C,WAAO,IAAI,iBAAgB;AAAA,MACzB,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,MACxC,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,MACxC,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,MACnD,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,MACxC,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,MACxC,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,IACrD,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,OAAyC;AAC9C,WAAO,IAAI,iBAAgB;AAAA,MACzB,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,MACxC,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,MACxC,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,MACpD,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,MACxC,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK;AAAA;AAAA,MACxC,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM;AAAA;AAAA,IACtD,CAAC;AAAA,EACH;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK;AAAA,EAC/C;AAAA,EAEA,IAAI,eAAe;AACjB,UAAM,MAAM,KAAK;AAEjB,WAAO,SAAS,GAAG,KAAK,SAAS,KAAK,GAAG,KAAK,SAAS,KAAK,GAAG,KAAK,QAAQ;AAAA,EAC9E;AAAA,EAEA,SAAS;AACP,UAAM,MAAM,KAAK;AAEjB,WAAO,IAAI,iBAAgB;AAAA,MACzB,KAAK,MAAM;AAAA;AAAA,MACX,CAAC,KAAK,MAAM;AAAA;AAAA,OACX,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,OAAO;AAAA;AAAA,MAC9C,CAAC,KAAK,MAAM;AAAA;AAAA,MACZ,KAAK,MAAM;AAAA;AAAA,OACV,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,OAAO;AAAA;AAAA,IAChD,CAAC;AAAA,EACH;AAAA,EAEA,IAAI,QAAkB;AACpB,WAAO,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,CAAC;AAAA,EAC7E;AAAA,EAEA,IAAI,eAA6B;AAC/B,WAAO,IAAI,aAAa,KAAK,KAAK;AAAA,EACpC;AAAA;AAAA,EAIA,WAAW,WAA4B;AACrC,WAAO,IAAI,iBAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AAAA,EAC/C;AAAA,EAEA,OAAO,OAAO,OAAe,QAAiC;AAC5D,UAAM,WAAW,IAAI,iBAAgB,CAAC,KAAK,IAAI,KAAK,GAAG,CAAC,KAAK,IAAI,KAAK,GAAG,GAAG,KAAK,IAAI,KAAK,GAAG,KAAK,IAAI,KAAK,GAAG,CAAC,CAAC;AAEhH,QAAI,WAAW,OAAO,MAAM,KAAK,OAAO,MAAM,IAAI;AAChD,aAAO,iBAAgB;AAAA,QACrB,iBAAgB,UAAU,OAAO,GAAG,OAAO,CAAC;AAAA,QAC5C;AAAA,QACA,iBAAgB,UAAU,CAAC,OAAO,GAAG,CAAC,OAAO,CAAC;AAAA,MAChD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAMA,OAAO,MAAM,IAAY,KAAa,IAAI,SAAgB,EAAE,GAAG,GAAG,GAAG,EAAE,GAAoB;AACzF,UAAM,QAAQ,IAAI,iBAAgB,CAAC,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;AAEtD,QAAI,OAAO,MAAM,KAAK,OAAO,MAAM,GAAG;AACpC,aAAO,iBAAgB;AAAA,QACrB,iBAAgB,UAAU,OAAO,GAAG,OAAO,CAAC;AAAA,QAC5C;AAAA,QACA,iBAAgB,UAAU,CAAC,OAAO,GAAG,CAAC,OAAO,CAAC;AAAA,MAChD;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAMA,OAAO,UAAU,IAAY,IAA6B;AACxD,WAAO,IAAI,iBAAgB,CAAC,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,CAAC;AAAA,EACjD;AAAA,EAMA,OAAO,YAAY,CAAC,OAAO,GAAG,IAAI,GAAuC;AACvE,QAAI,CAAC,MAAO,QAAO,iBAAgB;AACnC,WAAO,KAAK,OAAO,CAAC,QAAQ,SAAS,OAAO,QAAQ,IAAI,GAAG,KAAK;AAAA,EAClE;AAAA,EAEA,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,IAAI;AACN,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,KAAK;AACP,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,KAAK;AACP,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,kBAAyB;AAC3B,WAAO,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK,EAAE;AAAA,EAChC;AAAA,EAEA,IAAI,wBAA+B;AACjC,WAAO,EAAE,GAAG,KAAK,IAAI,GAAG,KAAK,GAAG;AAAA,EAClC;AAAA,EAEA,IAAI,iBAAwB;AAC1B,WAAO,EAAE,GAAG,KAAK,GAAG,GAAG,KAAK,EAAE;AAAA,EAChC;AAAA,EAEA,WAAW;AACT,WAAO,UAAU,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,KAAK,EAAE,KAAK,KAAK,EAAE;AAAA,EAClF;AACF;;;AC9KA,SAAS,OAAO,GAAS,KAAW,GAAiB;AACnD,MAAI,IAAI,IAAI;AACZ,MAAI,MAAM,cAAe,KAAI,IAAI;AACjC,MAAI,MAAM,eAAgB,KAAI,IAAI,OAAO,IAAI;AAC7C,MAAI,MAAM,eAAgB,KAAI,IAAI,OAAO,IAAI;AAC7C,MAAI,MAAM,gBAAiB,KAAI,IAAI;AACnC,MAAI,MAAM,SAAU,KAAI,IAAI,OAAO,IAAI,QAAQ;AAC/C,SAAO,EAAE,GAAG,GAAG,EAAE;AACnB;AAEA,SAAS,OAAO,GAAS,KAAW,GAAiB;AACnD,MAAI,IAAI,IAAI;AACZ,MAAI,MAAM,aAAc,KAAI,IAAI;AAChC,MAAI,MAAM,cAAe,KAAI,IAAI,OAAO,EAAE;AAC1C,MAAI,MAAM,gBAAiB,KAAI,IAAI,OAAO,EAAE;AAC5C,MAAI,MAAM,iBAAkB,KAAI,IAAI;AACpC,MAAI,MAAM,SAAU,KAAI,IAAI,OAAO,EAAE,SAAS;AAC9C,SAAO,EAAE,GAAG,GAAG,EAAE;AACnB;AAEO,SAAS,UAAU,GAAS,KAAW,SAA6B;AACzE,QAAM,EAAE,GAAG,EAAE,IAAI;AACjB,SAAO,OAAO,OAAO,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC;AACzC;;;ACvBA,IAAM,QAAQ,CAAC,OAAeA,MAAaC,SAAgB,KAAK,IAAI,KAAK,IAAI,OAAOD,IAAG,GAAGC,IAAG;AAEtF,IAAM,aAAa,CAAC,UAAiB,MAAY,iBAA2B;AACjF,QAAM,IAAI,MAAM,SAAS,GAAG,aAAa,GAAG,aAAa,IAAI,aAAa,QAAQ,KAAK,KAAK;AAC5F,QAAM,IAAI,MAAM,SAAS,GAAG,aAAa,GAAG,aAAa,IAAI,aAAa,SAAS,KAAK,MAAM;AAC9F,SAAO,EAAE,GAAG,EAAE;AAChB;AAEA,IAAM,iBAAuB;AAAA,EAC3B,OAAO;AAAA,EACP,QAAQ;AACV;AAEA,IAAM,iBAAuB;AAAA,EAC3B,OAAO;AAAA,EACP,QAAQ;AACV;AAEO,IAAM,YAAY,CAAC,MAAY,UAAU,gBAAgB,UAAU,mBAAmB;AAC3F,SAAO;AAAA,IACL,OAAO,KAAK,IAAI,KAAK,IAAI,KAAK,OAAO,QAAS,KAAK,GAAG,QAAS,KAAK;AAAA,IACpE,QAAQ,KAAK,IAAI,KAAK,IAAI,KAAK,QAAQ,QAAS,MAAM,GAAG,QAAS,MAAM;AAAA,EAC1E;AACF;;;ACnBO,IAAM,cAAc,CAAC,GAAW,OAAe,EAAE,GAAG,EAAE;AAEtD,IAAM,iBAAiB,CAAC,GAAU,MAAa,YAAY,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAC/E,IAAM,YAAY,CAAC,GAAU,MAAa,YAAY,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAE1E,SAAS,QAAQ,GAAoB;AAC1C,SAAO,QAAQ,IAAI,GAAG,GAAG,KAAK,QAAQ,IAAI,GAAG,GAAG;AAClD;AAMO,SAAS,WAAW,GAAmB;AAC5C,QAAM,EAAE,GAAG,GAAG,OAAO,OAAO,IAAI;AAChC,QAAM,OAAO,IAAI,QAAQ;AACzB,QAAM,OAAO,IAAI,SAAS;AAC1B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM,IAAI;AAAA,IACV,MAAM,IAAI;AAAA,IACV;AAAA,IACA;AAAA,IACA,QAAQ,YAAY,MAAM,IAAI;AAAA,EAChC;AACF;AAEO,SAAS,OAAO,GAAmB;AACxC,SAAO,QAAQ,IAAI,GAAG,GAAG,KAAK,QAAQ,IAAI,GAAG,GAAG,KAAK,QAAQ,IAAI,GAAG,OAAO,KAAK,QAAQ,IAAI,GAAG,QAAQ;AACzG;AAEO,SAAS,eAAe,GAAS;AACtC,QAAM,MAAM,YAAY,EAAE,MAAM,EAAE,IAAI;AACtC,QAAM,QAAQ,YAAY,EAAE,MAAM,EAAE,IAAI;AACxC,QAAM,SAAS,YAAY,EAAE,MAAM,EAAE,IAAI;AACzC,QAAM,OAAO,YAAY,EAAE,MAAM,EAAE,IAAI;AACvC,SAAO,EAAE,KAAK,OAAO,QAAQ,KAAK;AACpC;AAEO,SAAS,eAAe,GAAS;AACtC,QAAM,MAAM,YAAY,EAAE,MAAM,EAAE,IAAI;AACtC,QAAM,QAAQ,YAAY,EAAE,MAAM,EAAE,IAAI;AACxC,QAAM,SAAS,YAAY,EAAE,MAAM,EAAE,IAAI;AACzC,QAAM,OAAO,YAAY,EAAE,MAAM,EAAE,IAAI;AACvC,SAAO,EAAE,KAAK,OAAO,QAAQ,KAAK;AACpC;AAEO,SAAS,aAAa,GAAS;AACpC,QAAM,IAAI,eAAe,CAAC;AAC1B,QAAM,MAAgB,CAAC,EAAE,KAAK,EAAE,KAAK;AACrC,QAAM,QAAkB,CAAC,EAAE,OAAO,EAAE,MAAM;AAC1C,QAAM,SAAmB,CAAC,EAAE,MAAM,EAAE,MAAM;AAC1C,QAAM,OAAiB,CAAC,EAAE,KAAK,EAAE,IAAI;AACrC,SAAO,EAAE,KAAK,OAAO,QAAQ,KAAK;AACpC;;;AC3DO,SAAS,WAAW,GAAS,GAAkB;AACpD,SAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE;AACpE;AAKO,SAAS,aAAa,GAAS,GAAe;AACnD,QAAM,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,CAAC;AAC3B,QAAM,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,CAAC;AAC3B,QAAM,KAAK,KAAK,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK;AAChD,QAAM,KAAK,KAAK,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM;AAClD,SAAO,WAAW,EAAE,GAAG,GAAG,OAAO,KAAK,GAAG,QAAQ,KAAK,EAAE,CAAC;AAC3D;AAKO,SAAS,WAAW,GAAS,GAAoC;AACtE,SAAO;AAAA,IACL,KAAK,EAAE,QAAQ,EAAE;AAAA,IACjB,OAAO,EAAE,QAAQ,EAAE;AAAA,IACnB,QAAQ,EAAE,QAAQ,EAAE;AAAA,IACpB,MAAM,EAAE,QAAQ,EAAE;AAAA,EACpB;AACF;;;ACxBO,SAAS,SAAS,GAAU,IAAW,EAAE,GAAG,GAAG,GAAG,EAAE,GAAW;AACpE,SAAO,KAAK,KAAK,KAAK,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,KAAK,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AAClE;AAEO,SAAS,kBAAkB,GAAS,GAAyB;AAClE,MAAI,IAAI;AACR,MAAI,IAAI;AAER,MAAI,EAAE,IAAI,EAAE,EAAG,KAAI,EAAE,IAAI,EAAE;AAAA,WAClB,EAAE,IAAI,EAAE,KAAM,KAAI,EAAE,IAAI,EAAE;AAEnC,MAAI,EAAE,IAAI,EAAE,EAAG,KAAI,EAAE,IAAI,EAAE;AAAA,WAClB,EAAE,IAAI,EAAE,KAAM,KAAI,EAAE,IAAI,EAAE;AACnC,SAAO,EAAE,GAAG,GAAG,OAAO,SAAS,EAAE,GAAG,EAAE,CAAC,EAAE;AAC3C;AAEO,SAAS,iBAAiB,GAAS,GAAwB;AAChE,MAAI,WAAW,GAAG,CAAC,EAAG,QAAO,EAAE,GAAG,GAAG,GAAG,GAAG,OAAO,EAAE;AACpD,QAAM,OAAO,EAAE,IAAI,EAAE,IAAI,IAAI;AAC7B,QAAM,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI;AAC9B,QAAM,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI;AAC9B,QAAM,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI;AAC9B,MAAI,IAAI,KAAK,MAAM,MAAM,IAAI,IAAI,MAAM,IAAI,KAAK;AAChD,MAAI,KAAK,IAAI,GAAG,CAAC;AACjB,MAAI,IAAI,MAAM,MAAM,MAAM,IAAI,IAAI,MAAM,IAAI,MAAM;AAClD,MAAI,KAAK,IAAI,GAAG,CAAC;AACjB,SAAO,EAAE,GAAG,GAAG,OAAO,SAAS,EAAE,GAAG,EAAE,CAAC,EAAE;AAC3C;AAEO,SAAS,iBAAiB,GAAS,GAAmC;AAC3E,SAAO;AAAA,IACL,MAAM,EAAE,IAAI,EAAE;AAAA,IACd,KAAK,EAAE,IAAI,EAAE;AAAA,IACb,OAAO,EAAE,OAAO,EAAE;AAAA,IAClB,QAAQ,EAAE,OAAO,EAAE;AAAA,EACrB;AACF;;;ACxCO,SAAS,WAAW,KAAc;AACvC,SAAO,CAAC,MAAoB;AAC1B,UAAM,KAAK,IAAI,IAAI,CAAC,MAAM,SAAS,GAAG,CAAC,CAAC;AACxC,UAAM,IAAI,KAAK,IAAI,MAAM,MAAM,EAAE;AACjC,WAAO,IAAI,GAAG,QAAQ,CAAC,CAAC;AAAA,EAC1B;AACF;AAEO,SAAS,kBAAkB,KAAW,GAAmB;AAC9D,MAAI,EAAE,QAAQ,IAAI,KAAM,QAAO;AAC/B,MAAI,EAAE,QAAQ,IAAI,KAAM,QAAO;AAC/B,MAAI,EAAE,QAAQ,IAAI,KAAM,QAAO;AAC/B,MAAI,EAAE,QAAQ,IAAI,KAAM,QAAO;AAC/B,SAAO;AACT;AAEO,SAAS,mBAAmB,KAAW,GAAoB;AAChE,QAAM,EAAE,GAAG,EAAE,IAAI;AAEjB,QAAM,KAAK,IAAI,IAAI;AACnB,QAAM,KAAK,IAAI,OAAO;AACtB,QAAM,KAAK,IAAI,IAAI;AACnB,QAAM,KAAK,IAAI,OAAO;AAEtB,MAAIC,WAAU;AACd,MAAI,OAAiB;AAErB,MAAI,KAAKA,UAAS;AAChB,IAAAA,WAAU;AACV,WAAO;AAAA,EACT;AACA,MAAI,KAAKA,UAAS;AAChB,IAAAA,WAAU;AACV,WAAO;AAAA,EACT;AACA,MAAI,KAAKA,UAAS;AAChB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACvCO,IAAM,gBAAgB,CAAC,MAAgB,aAAiC;AAC7E,QAAM,OAAO,KAAK,IAAI,SAAS,GAAG,KAAK,IAAI,KAAK,GAAG,SAAS,IAAI,SAAS,QAAQ,KAAK,KAAK,CAAC;AAC5F,QAAM,MAAM,KAAK,IAAI,SAAS,GAAG,KAAK,IAAI,KAAK,GAAG,SAAS,IAAI,SAAS,SAAS,KAAK,MAAM,CAAC;AAE7F,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO,KAAK,IAAI,KAAK,OAAO,SAAS,KAAK;AAAA,IAC1C,QAAQ,KAAK,IAAI,KAAK,QAAQ,SAAS,MAAM;AAAA,EAC/C;AACF;;;ACXO,SAAS,cAAc,GAAS,GAAmB;AACxD,SAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE;AACrE;AAEO,SAAS,aAAa,GAAS,GAAkB;AACtD,SAAO,OAAO,OAAO,eAAe,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,CAAC;AAC1E;AAEO,SAAS,SAAS,GAAS,GAA0B;AAC1D,SAAO,OAAO,CAAC,IAAI,aAAa,GAAG,CAAC,IAAI,cAAc,GAAG,CAAC;AAC5D;;;ACXO,IAAM,cAAc,CAAC,GAAS,MAAY;AAC/C,SAAO,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE;AAC/C;AAEO,IAAM,eAAe,CAAC,GAAU,MAAa;AAClD,SAAO,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;AAClC;AAEO,IAAM,cAAc,CAAC,GAAa,MAAgB;AACvD,SAAO,aAAa,GAAG,CAAC,KAAK,YAAY,GAAG,CAAC;AAC/C;;;ACTA,IAAM,aAAa,oBAAI,QAA0B;AAEjD,SAAS,sBAAsB,IAAiB;AAC9C,MAAI,CAAC,WAAW,IAAI,EAAE,GAAG;AACvB,UAAM,MAAM,GAAG,cAAc,eAAe;AAC5C,eAAW,IAAI,IAAI,IAAI,iBAAiB,EAAE,CAAC;AAAA,EAC7C;AACA,SAAO,WAAW,IAAI,EAAE;AAC1B;AAEO,SAAS,eAAe,IAAiB,OAA2B,CAAC,GAAS;AACnF,SAAO,WAAW,cAAc,IAAI,IAAI,CAAC;AAC3C;AAaA,SAAS,cAAc,IAAiB,OAA2B,CAAC,GAAG;AACrE,QAAM,EAAE,mBAAmB,OAAO,iBAAiB,MAAM,IAAI;AAE7D,QAAM,EAAE,GAAG,GAAG,OAAO,OAAO,IAAI,GAAG,sBAAsB;AACzD,QAAM,IAAI,EAAE,GAAG,GAAG,OAAO,OAAO;AAEhC,QAAM,QAAQ,sBAAsB,EAAE;AAEtC,QAAM,EAAE,iBAAiB,gBAAgB,kBAAkB,kBAAkB,IAAI;AAEjF,QAAM,eAAe,IAAI,iBAAiB,gBAAgB;AAC1D,QAAM,eAAe,IAAI,gBAAgB,iBAAiB;AAE1D,MAAI,gBAAgB;AAClB,MAAE,SAAS;AACX,MAAE,UAAU;AACZ,MAAE,KAAK,GAAG,eAAe;AACzB,MAAE,KAAK,GAAG,cAAc;AAAA,EAC1B;AAEA,MAAI,kBAAkB;AACpB,UAAM,iBAAiB,GAAG,cAAc,GAAG,cAAc;AACzD,UAAM,kBAAkB,GAAG,eAAe,GAAG,eAAe;AAC5D,MAAE,SAAS;AACX,MAAE,UAAU;AAAA,EACd;AAEA,SAAO;AACT;AAEA,IAAM,KAAK,CAAC,MAAc,WAAW,EAAE,QAAQ,MAAM,EAAE,CAAC;AAExD,IAAM,MAAM,IAAI,SAAmB,KAAK,OAAO,CAACC,MAAK,MAAMA,QAAO,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC;;;ACzD5E,SAAS,qBAAqB,KAAoB;AACvD,QAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;AAC7B,QAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;AAE7B,QAAM,IAAI,KAAK,IAAI,GAAG,EAAE;AACxB,QAAM,IAAI,KAAK,IAAI,GAAG,EAAE;AAExB,QAAM,QAAQ,KAAK,IAAI,GAAG,EAAE,IAAI;AAChC,QAAM,SAAS,KAAK,IAAI,GAAG,EAAE,IAAI;AAEjC,SAAO,WAAW,EAAE,GAAG,GAAG,OAAO,OAAO,CAAC;AAC3C;;;ACXA,IAAM,EAAE,KAAK,IAAI,IAAI;AAEd,SAAS,SAAS,IAAkB;AACzC,QAAM,OAAO;AAAA,IACX,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,IAC/B,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,EACjC;AACA,QAAM,OAAO;AAAA,IACX,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,IAC/B,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,EACjC;AACA,SAAO,kBAAkB,MAAM,IAAI;AACrC;;;ACVO,SAAS,UAAU,OAAoB;AAC5C,MAAI,KAAa,CAAC;AAClB,QAAM,QAAQ,MAAM,KAAK,MAAM,eAAe,CAAC;AAE/C,MAAI,MAAM,QAAQ;AAChB,SAAK,GAAG,OAAO,MAAM,IAAI,UAAU,CAAC;AACpC,WAAO,MAAM,MAAM,QAAW,EAAE;AAAA,EAClC;AAEA,MAAI,QAAkC,MAAM;AAE5C,MAAI,MAAM,aAAa,KAAK,WAAW;AACrC,YAAQ,MAAM;AAAA,EAChB;AAEA,MAAI,iBAAiB,aAAa;AAChC,UAAM,IAAI,eAAe,KAAK;AAC9B,OAAG,KAAK,EAAE,GAAG,GAAG,GAAG,EAAE,MAAM,OAAO,EAAE,CAAC;AAAA,EACvC;AAEA,SAAO,MAAM,MAAM,QAAW,EAAE;AAClC;;;ACvBO,SAAS,MAAM,GAAW;AAC/B,SAAS,IAAI,MAAO,KAAK,KAAM;AACjC;AAEO,SAAS,OAAO,GAAU,GAAW,GAAiB;AAC3D,QAAM,IAAI,MAAM,CAAC;AAEjB,QAAM,MAAM,KAAK,IAAI,CAAC;AACtB,QAAM,MAAM,KAAK,IAAI,CAAC;AAEtB,QAAM,IAAI,EAAE,IAAI,EAAE;AAClB,QAAM,IAAI,EAAE,IAAI,EAAE;AAElB,SAAO;AAAA,IACL,GAAG,EAAE,IAAI,IAAI,MAAM,IAAI;AAAA,IACvB,GAAG,EAAE,IAAI,IAAI,MAAM,IAAI;AAAA,EACzB;AACF;AAEO,SAAS,gBAAgB,GAAS,KAAmB;AAC1D,QAAM,KAAK,OAAO,OAAO,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,MAAM,CAAC;AAE/E,QAAM,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AAC5B,QAAM,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AAE5B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAE3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAC3B,QAAM,OAAO,KAAK,IAAI,GAAG,EAAE;AAE3B,SAAO,WAAW;AAAA,IAChB,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO;AAAA,EACjB,CAAC;AACH;;;AC3BO,SAAS,cAAc,KAAa,OAA0B,CAAC,GAAS;AAC7E,SAAO,WAAW,gBAAgB,KAAK,IAAI,CAAC;AAC9C;AAKO,SAAS,gBAAgB,KAAa,MAAyB;AACpE,QAAM,EAAE,mBAAmB,MAAM,IAAI;AACrC,QAAM,EAAE,YAAY,aAAa,UAAU,KAAK,eAAe,IAAI;AACnE,QAAM,QAAQ,gBAAgB,SAAS;AACvC,QAAM,SAAS,gBAAgB,UAAU;AACzC,QAAM,OAAO,EAAE,GAAG,GAAG,GAAG,GAAG,OAAO,OAAO;AACzC,MAAI,kBAAkB;AACpB,UAAM,iBAAiB,aAAa,IAAI,gBAAgB;AACxD,UAAM,kBAAkB,cAAc,IAAI,gBAAgB;AAC1D,SAAK,SAAS;AACd,SAAK,UAAU;AAAA,EACjB;AACA,SAAO;AACT;;;AC9BO,IAAM,cAAc,CAAC,MAAoC,QAAQ,KAAK,QAAQ;AAE9E,SAAS,MAAM,GAAS,GAAyC;AACtE,QAAM,IAAI,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,OAAO,EAAE,IAAI,KAAK,EAAE,IAAI,QAAQ,EAAE,GAAG,IAAI;AAClF,QAAM,EAAE,MAAM,GAAG,QAAQ,GAAG,SAAS,GAAG,OAAO,EAAE,IAAI;AACrD,SAAO,WAAW;AAAA,IAChB,GAAG,EAAE,IAAI;AAAA,IACT,GAAG,EAAE,IAAI;AAAA,IACT,OAAO,EAAE,QAAQ,OAAO;AAAA,IACxB,QAAQ,EAAE,SAAS,MAAM;AAAA,EAC3B,CAAC;AACH;AAEO,SAAS,OAAO,GAAS,GAAsC;AACpE,QAAM,QAAQ,OAAO,MAAM,WAAW,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,IAAI;AAC3D,SAAO,MAAM,GAAG,KAAK;AACvB;AAEO,SAAS,OAAO,GAAS,GAAsC;AACpE,QAAM,QAAQ,OAAO,MAAM,WAAW,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,IAAI;AAC3D,SAAO,MAAM,GAAG,KAAK;AACvB;AAEO,SAAS,MAAM,GAAS,GAAyB;AACtD,QAAM,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI;AACzB,SAAO,WAAW;AAAA,IAChB,GAAG,EAAE,IAAI;AAAA,IACT,GAAG,EAAE,IAAI;AAAA,IACT,OAAO,EAAE;AAAA,IACT,QAAQ,EAAE;AAAA,EACZ,CAAC;AACH;;;AC/BO,SAAS,kBAAkB,WAAqB,WAAmB;AACxE,QAAM,OAAO,WAAW,SAAS;AACjC,QAAM,EAAE,KAAK,OAAO,MAAM,OAAO,IAAI,eAAe,IAAI;AACxD,QAAM,CAAC,IAAI,IAAI,UAAU,MAAM,GAAG;AAElC,SAAO;AAAA,IACL,KAAK,CAAC,MAAM,KAAK,OAAO,MAAM;AAAA,IAC9B,OAAO,CAAC,KAAK,OAAO,QAAQ,IAAI;AAAA,IAChC,QAAQ,CAAC,KAAK,MAAM,QAAQ,KAAK;AAAA,IACjC,MAAM,CAAC,OAAO,KAAK,MAAM,MAAM;AAAA,EACjC,EAAE,IAAI;AACR;AAEO,SAAS,iBAAiB,SAAkB,OAAc;AAC/D,QAAM,EAAE,GAAG,EAAE,IAAI;AACjB,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,QAAQ,SAAS,GAAG,IAAI,QAAQ,QAAQ,IAAI,KAAK;AACnE,UAAM,KAAK,QAAQ,CAAC,EAAE;AACtB,UAAM,KAAK,QAAQ,CAAC,EAAE;AACtB,UAAM,KAAK,QAAQ,CAAC,EAAE;AACtB,UAAM,KAAK,QAAQ,CAAC,EAAE;AAEtB,QAAI,KAAK,MAAM,KAAK,KAAK,KAAM,KAAK,OAAO,IAAI,OAAQ,KAAK,MAAM,IAAI;AACpE,UAAI,CAAC;AAAA,IACP;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,uBAAuB;AAC9B,QAAM,KAAK;AACX,QAAM,kBAAkB,SAAS,eAAe,EAAE;AAClD,MAAI,iBAAiB;AACnB,WAAO;AAAA,EACT;AACA,QAAM,MAAM,SAAS,gBAAgB,8BAA8B,KAAK;AACxE,SAAO,OAAO,IAAI,OAAO;AAAA,IACvB,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,UAAU;AAAA,IACV,eAAe;AAAA,IACf,MAAM;AAAA,EACR,CAAC;AAED,QAAM,UAAU,SAAS,gBAAgB,8BAA8B,SAAS;AAChF,UAAQ,aAAa,MAAM,EAAE;AAC7B,UAAQ,aAAa,UAAU,SAAS;AACxC,MAAI,YAAY,OAAO;AACvB,WAAS,KAAK,YAAY,GAAG;AAC7B,SAAO;AACT;AAEO,SAAS,aAAa,SAAkB;AAC7C,QAAM,KAAK,qBAAqB;AAChC,QAAM,SAAS,QAAQ,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,EAAE,KAAK,GAAG;AACvE,KAAG,aAAa,UAAU,MAAM;AAChC,SAAO,MAAM;AACX,OAAG,OAAO;AAAA,EACZ;AACF;;;AC9DO,IAAM,sBAAuD;AAAA,EAClE,GAAG,EAAE,GAAG,KAAK,GAAG,EAAE;AAAA,EAClB,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,EACjB,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI;AAAA,EAClB,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,EACjB,GAAG,EAAE,GAAG,KAAK,GAAG,EAAE;AAAA,EAClB,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,EACjB,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI;AAAA,EAClB,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE;AACnB;AAEO,IAAM,uBAAmE;AAAA,EAC9E,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,GAAG;AAAA,EACH,IAAI;AACN;;;ACpBA,IAAM,EAAE,MAAM,KAAK,KAAAC,KAAI,IAAI;AAE3B,SAAS,mBAAmB,MAAY,WAA6B;AACnE,QAAM,EAAE,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK,IAAI;AAC/C,QAAM,IAAI,UAAU,SAAS,GAAG,IAAI,OAAO,UAAU,SAAS,GAAG,IAAI,OAAO;AAC5E,QAAM,IAAI,UAAU,SAAS,GAAG,IAAI,OAAO,UAAU,SAAS,GAAG,IAAI,OAAO;AAC5E,SAAO,EAAE,GAAG,EAAE;AAChB;AAEA,SAAS,qBAAqB,WAA6B;AACzD,SAAO,qBAAqB,SAAS;AACvC;AAEO,SAAS,WAAW,MAAY,QAAe,WAA6B,MAAsB;AACvG,QAAM,EAAE,mBAAmB,gBAAgB,IAAI;AAE/C,QAAM,SAAS,mBAAmB,MAAM,SAAS;AAEjD,QAAM,oBAAoB,qBAAqB,SAAS;AACxD,QAAM,iBAAiB,mBAAmB,MAAM,iBAAiB;AAEjE,MAAI,sBAAsB,UAAU;AAClC,aAAS,EAAE,GAAG,OAAO,IAAI,GAAG,GAAG,OAAO,IAAI,EAAE;AAAA,EAC9C;AAEA,QAAM,YAAY;AAAA,IAChB,GAAG,OAAO,IAAI,OAAO;AAAA,IACrB,GAAG,OAAO,IAAI,OAAO;AAAA,EACvB;AAEA,QAAM,aAAa;AAAA,IACjB,GAAG,oBAAoB,SAAS,EAAE,IAAI,IAAI;AAAA,IAC1C,GAAG,oBAAoB,SAAS,EAAE,IAAI,IAAI;AAAA,EAC5C;AAEA,QAAM,UAAU;AAAA,IACd,OAAO,UAAU,IAAI,eAAe;AAAA,IACpC,QAAQ,UAAU,IAAI,eAAe;AAAA,EACvC;AAEA,QAAM,SAAU,WAAW,IAAI,QAAQ,QAAS,KAAK;AACrD,QAAM,SAAU,WAAW,IAAI,QAAQ,SAAU,KAAK;AAEtD,QAAM,mBAAmB,IAAI,MAAM,IAAI,IAAI,MAAM,IAAI,SAAS;AAE9D,QAAM,QAAQ,kBACV,EAAE,GAAG,kBAAkB,GAAG,iBAAiB,IAC3C;AAAA,IACE,GAAG,OAAO,MAAM,eAAe,IAAI,IAAI;AAAA,IACvC,GAAG,OAAO,MAAM,eAAe,IAAI,IAAI;AAAA,EACzC;AAEJ,MAAI,OAAO,MAAM,eAAe,GAAG;AACjC,UAAM,IAAI,IAAI,MAAM,CAAC;AAAA,EACvB,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK,MAAM,GAAG;AACzC,UAAM,KAAK;AAAA,EACb;AAEA,MAAI,OAAO,MAAM,eAAe,GAAG;AACjC,UAAM,IAAI,IAAI,MAAM,CAAC;AAAA,EACvB,WAAW,KAAK,MAAM,CAAC,MAAM,KAAK,MAAM,GAAG;AACzC,UAAM,KAAK;AAAA,EACb;AAEA,UAAQ,mBAAmB;AAAA,IACzB,KAAK;AACH,aAAO,cAAc,MAAM,gBAAgB,MAAM,MAAM,GAAG,MAAM,GAAG,cAAc,GAAG,KAAK;AAAA,IAC3F,KAAK;AACH,aAAO;AAAA,QACL;AAAA,QACA,gBAAgB,MAAM,MAAM,GAAG,MAAM,GAAG;AAAA,UACtC,GAAG,KAAK;AAAA,UACR,GAAG,KAAK;AAAA,QACV,CAAC;AAAA,QACD;AAAA,MACF;AAAA,EACJ;AACF;AAEA,SAAS,qBAAqB,cAAqB,YAAmB,aAAsB,MAAgB;AAC1G,MAAI,YAAY;AACd,WAAO;AAAA,MACL,GAAGA,KAAI,WAAW,GAAG,aAAa,CAAC;AAAA,MACnC,GAAGA,KAAI,WAAW,GAAG,aAAa,CAAC;AAAA,MACnC,OAAO,IAAI,WAAW,IAAI,aAAa,CAAC;AAAA,MACxC,QAAQ,IAAI,WAAW,IAAI,aAAa,CAAC;AAAA,IAC3C;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG,aAAa;AAAA,IAChB,GAAG,aAAa;AAAA,IAChB,OAAO,WAAW,IAAI,aAAa;AAAA,IACnC,QAAQ,WAAW,IAAI,aAAa;AAAA,EACtC;AACF;AAEA,SAAS,cAAc,MAAY,WAA4B,aAAa,MAAgB;AAC1F,QAAM,KAAK,UAAU,QAAQ,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC;AAC3D,QAAM,KAAK,UAAU,QAAQ,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC;AAC3D,SAAO,qBAAqB,IAAI,IAAI,UAAU;AAChD;","names":["min","max","closest","sum","min"]}