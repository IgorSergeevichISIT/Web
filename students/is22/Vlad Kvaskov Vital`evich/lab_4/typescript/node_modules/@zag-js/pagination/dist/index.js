"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  ellipsisProps: () => ellipsisProps,
  itemProps: () => itemProps,
  machine: () => machine,
  props: () => props,
  splitEllipsisProps: () => splitEllipsisProps,
  splitItemProps: () => splitItemProps,
  splitProps: () => splitProps
});
module.exports = __toCommonJS(src_exports);

// src/pagination.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts = anatomy.build();

// src/pagination.connect.ts
var import_dom_query2 = require("@zag-js/dom-query");

// src/pagination.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `pagination:${ctx.id}`,
  getPrevTriggerId: (ctx) => ctx.ids?.prevTrigger ?? `pagination:${ctx.id}:prev`,
  getNextTriggerId: (ctx) => ctx.ids?.nextTrigger ?? `pagination:${ctx.id}:next`,
  getEllipsisId: (ctx, index) => ctx.ids?.ellipsis?.(index) ?? `pagination:${ctx.id}:ellipsis:${index}`,
  getItemId: (ctx, page) => ctx.ids?.item?.(page) ?? `pagination:${ctx.id}:item:${page}`
});

// src/pagination.utils.ts
var range = (start, end) => {
  let length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));

// src/pagination.connect.ts
function connect(state, send, normalize) {
  const totalPages = state.context.totalPages;
  const page = state.context.page;
  const translations = state.context.translations;
  const previousPage = state.context.previousPage;
  const nextPage = state.context.nextPage;
  const pageRange = state.context.pageRange;
  const type = state.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange(state.context);
  return {
    page,
    pageSize: state.context.pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count) {
      send({ type: "SET_COUNT", count });
    },
    setPageSize(size) {
      send({ type: "SET_PAGE_SIZE", size });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize.element({
        id: dom.getRootId(state.context),
        ...parts.root.attrs,
        dir: state.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props2) {
      return normalize.element({
        id: dom.getEllipsisId(state.context, props2.index),
        ...parts.ellipsis.attrs,
        dir: state.context.dir
      });
    },
    getItemProps(props2) {
      const index = props2.value;
      const isCurrentPage = index === state.context.page;
      return normalize.element({
        id: dom.getItemId(state.context, index),
        ...parts.item.attrs,
        dir: state.context.dir,
        "data-index": index,
        "data-selected": (0, import_dom_query2.dataAttr)(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": translations.itemLabel?.({ page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize.element({
        id: dom.getPrevTriggerId(state.context),
        ...parts.prevTrigger.attrs,
        dir: state.context.dir,
        "data-disabled": (0, import_dom_query2.dataAttr)(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize.element({
        id: dom.getNextTriggerId(state.context),
        ...parts.nextTrigger.attrs,
        dir: state.context.dir,
        "data-disabled": (0, import_dom_query2.dataAttr)(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}

// src/pagination.machine.ts
var import_core = require("@zag-js/core");
var import_utils = require("@zag-js/utils");
var defaultTranslations = {
  rootLabel: "pagination",
  prevTriggerLabel: "previous page",
  nextTriggerLabel: "next page",
  itemLabel({ page, totalPages }) {
    const isLastPage = totalPages > 1 && page === totalPages;
    return `${isLastPage ? "last page, " : ""}page ${page}`;
  }
};
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          ...defaultTranslations,
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = start + ctx2.pageSize;
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        FIRST_PAGE: {
          actions: "goToFirstPage"
        },
        LAST_PAGE: {
          actions: "goToLastPage"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set.page(ctx2, 1);
        },
        goToLastPage(ctx2) {
          set.page(ctx2, ctx2.totalPages);
        },
        goToPrevPage(ctx2) {
          set.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage) return;
          set.page(ctx2, 1);
        }
      }
    }
  );
}
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var set = {
  pageSize: (ctx, value) => {
    if ((0, import_utils.isEqual)(ctx.pageSize, value)) return;
    ctx.pageSize = value;
    ctx.onPageSizeChange?.({ pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    if ((0, import_utils.isEqual)(ctx.page, value)) return;
    ctx.page = clampPage(value, ctx.totalPages);
    ctx.onPageChange?.({ page: ctx.page, pageSize: ctx.pageSize });
  }
};

// src/pagination.props.ts
var import_types = require("@zag-js/types");
var import_utils2 = require("@zag-js/utils");
var props = (0, import_types.createProps)()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps = (0, import_utils2.createSplitProps)(props);
var itemProps = (0, import_types.createProps)()(["value", "type"]);
var splitItemProps = (0, import_utils2.createSplitProps)(itemProps);
var ellipsisProps = (0, import_types.createProps)()(["index"]);
var splitEllipsisProps = (0, import_utils2.createSplitProps)(ellipsisProps);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  ellipsisProps,
  itemProps,
  machine,
  props,
  splitEllipsisProps,
  splitItemProps,
  splitProps
});
//# sourceMappingURL=index.js.map