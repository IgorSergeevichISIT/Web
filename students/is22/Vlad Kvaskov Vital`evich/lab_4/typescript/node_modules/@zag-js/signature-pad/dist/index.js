"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  anatomy: () => anatomy,
  connect: () => connect,
  machine: () => machine,
  props: () => props,
  splitProps: () => splitProps
});
module.exports = __toCommonJS(src_exports);

// src/signature-pad.anatomy.ts
var import_anatomy = require("@zag-js/anatomy");
var anatomy = (0, import_anatomy.createAnatomy)("signature-pad").parts(
  "root",
  "control",
  "segment",
  "segmentPath",
  "guide",
  "clearTrigger",
  "label"
);
var parts = anatomy.build();

// src/signature-pad.connect.ts
var import_dom_event = require("@zag-js/dom-event");
var import_dom_query2 = require("@zag-js/dom-query");

// src/signature-pad.dom.ts
var import_dom_query = require("@zag-js/dom-query");
var dom = (0, import_dom_query.createScope)({
  getRootId: (ctx) => ctx.ids?.root ?? `signature-${ctx.id}`,
  getControlId: (ctx) => ctx.ids?.control ?? `signature-control-${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `signature-label-${ctx.id}`,
  getHiddenInputId: (ctx) => ctx.ids?.hiddenInput ?? `signature-input-${ctx.id}`,
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getSegmentEl: (ctx) => (0, import_dom_query.query)(dom.getControlEl(ctx), "[data-part=segment]"),
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx)),
  getDataUrl: (ctx, options) => {
    if (ctx.isEmpty) return Promise.resolve("");
    return (0, import_dom_query.getDataUrl)(dom.getSegmentEl(ctx), options);
  }
});

// src/signature-pad.connect.ts
var defaultTranslations = {
  control: "signature pad",
  clearTrigger: "clear signature"
};
function connect(state, send, normalize) {
  const drawing = state.matches("drawing");
  const empty = state.context.isEmpty;
  const interactive = state.context.isInteractive;
  const disabled = !!state.context.disabled;
  const translations = state.context.translations || defaultTranslations;
  return {
    empty,
    drawing,
    currentPath: state.context.currentPath,
    paths: state.context.paths,
    clear() {
      send({ type: "CLEAR" });
    },
    getDataUrl(type, quality) {
      return dom.getDataUrl(state.context, { type, quality });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        id: dom.getLabelId(state.context),
        "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
        htmlFor: dom.getHiddenInputId(state.context),
        onClick(event) {
          if (!interactive) return;
          if (event.defaultPrevented) return;
          const controlEl = dom.getControlEl(state.context);
          controlEl?.focus({ preventScroll: true });
        }
      });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
        id: dom.getRootId(state.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        tabIndex: disabled ? void 0 : 0,
        id: dom.getControlId(state.context),
        role: "application",
        "aria-roledescription": "signature pad",
        "aria-label": translations.control,
        "aria-disabled": disabled,
        "data-disabled": (0, import_dom_query2.dataAttr)(disabled),
        onPointerDown(event) {
          if (!(0, import_dom_event.isLeftClick)(event)) return;
          if ((0, import_dom_event.isModifierKey)(event)) return;
          if (!interactive) return;
          const target = (0, import_dom_query2.getEventTarget)(event);
          if (target?.closest("[data-part=clear-trigger]")) return;
          event.currentTarget.setPointerCapture(event.pointerId);
          const point = { x: event.clientX, y: event.clientY };
          const { offset } = (0, import_dom_event.getRelativePoint)(point, dom.getControlEl(state.context));
          send({ type: "POINTER_DOWN", point: offset, pressure: event.pressure });
        },
        onPointerUp(event) {
          if (!interactive) return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        style: {
          position: "relative",
          touchAction: "none",
          userSelect: "none",
          WebkitUserSelect: "none"
        }
      });
    },
    getSegmentProps() {
      return normalize.svg({
        ...parts.segment.attrs,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          fill: state.context.drawing.fill
        }
      });
    },
    getSegmentPathProps(props2) {
      return normalize.path({
        ...parts.segmentPath.attrs,
        d: props2.path
      });
    },
    getGuideProps() {
      return normalize.element({
        ...parts.guide.attrs,
        "data-disabled": (0, import_dom_query2.dataAttr)(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts.clearTrigger.attrs,
        type: "button",
        "aria-label": translations.clearTrigger,
        hidden: !state.context.paths.length || drawing,
        disabled,
        onClick() {
          send({ type: "CLEAR" });
        }
      });
    },
    getHiddenInputProps(props2) {
      return normalize.input({
        id: dom.getHiddenInputId(state.context),
        type: "text",
        hidden: true,
        disabled,
        required: state.context.required,
        readOnly: state.context.readOnly,
        name: state.context.name,
        value: props2.value
      });
    }
  };
}

// src/signature-pad.machine.ts
var import_core = require("@zag-js/core");
var import_dom_event2 = require("@zag-js/dom-event");
var import_utils = require("@zag-js/utils");
var import_perfect_freehand = __toESM(require("perfect-freehand"));

// src/get-svg-path.ts
var average = (a, b) => (a + b) / 2;
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return "";
  }
  let a = points[0];
  let b = points[1];
  const c = points[2];
  let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(
    b[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max = len - 1; i < max; i++) {
    a = points[i];
    b = points[i + 1];
    result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}

// src/signature-pad.machine.ts
function machine(userContext) {
  const ctx = (0, import_utils.compact)(userContext);
  return (0, import_core.createMachine)(
    {
      id: "signature-pad",
      initial: "idle",
      context: {
        readOnly: false,
        disabled: false,
        ...ctx,
        paths: [],
        currentPoints: [],
        currentPath: null,
        drawing: {
          size: 2,
          simulatePressure: false,
          thinning: 0.7,
          smoothing: 0.4,
          streamline: 0.6,
          ...ctx.drawing
        }
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isEmpty: (ctx2) => ctx2.paths.length === 0
      },
      on: {
        CLEAR: {
          actions: ["clearPoints", "invokeOnDrawEnd", "focusCanvasEl"]
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "drawing",
              actions: ["addPoint"]
            }
          }
        },
        drawing: {
          activities: ["trackPointerMove"],
          on: {
            POINTER_MOVE: {
              actions: ["addPoint", "invokeOnDraw"]
            },
            POINTER_UP: {
              target: "idle",
              actions: ["endStroke", "invokeOnDrawEnd"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackPointerMove(ctx2, _evt, { send }) {
          const doc = dom.getDoc(ctx2);
          return (0, import_dom_event2.trackPointerMove)(doc, {
            onPointerMove({ event, point }) {
              const { offset } = (0, import_dom_event2.getRelativePoint)(point, dom.getControlEl(ctx2));
              send({ type: "POINTER_MOVE", point: offset, pressure: event.pressure });
            },
            onPointerUp() {
              send({ type: "POINTER_UP" });
            }
          });
        }
      },
      actions: {
        addPoint(ctx2, evt) {
          ctx2.currentPoints.push(evt.point);
          const stroke = (0, import_perfect_freehand.default)(ctx2.currentPoints, ctx2.drawing);
          ctx2.currentPath = getSvgPathFromStroke(stroke);
        },
        endStroke(ctx2) {
          ctx2.paths.push(ctx2.currentPath);
          ctx2.currentPoints = [];
          ctx2.currentPath = null;
        },
        clearPoints(ctx2) {
          ctx2.currentPoints = [];
          ctx2.paths = [];
        },
        focusCanvasEl(ctx2) {
          queueMicrotask(() => {
            dom.getControlEl(ctx2)?.focus({ preventScroll: true });
          });
        },
        invokeOnDraw(ctx2) {
          ctx2.onDraw?.({
            paths: [...ctx2.paths, ctx2.currentPath]
          });
        },
        invokeOnDrawEnd(ctx2) {
          ctx2.onDrawEnd?.({
            paths: [...ctx2.paths],
            getDataUrl(type, quality = 0.92) {
              return dom.getDataUrl(ctx2, { type, quality });
            }
          });
        }
      }
    }
  );
}

// src/signature-pad.props.ts
var import_types = require("@zag-js/types");
var import_utils2 = require("@zag-js/utils");
var props = (0, import_types.createProps)()([
  "dir",
  "disabled",
  "drawing",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onDraw",
  "onDrawEnd",
  "readOnly",
  "required",
  "translations"
]);
var splitProps = (0, import_utils2.createSplitProps)(props);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  anatomy,
  connect,
  machine,
  props,
  splitProps
});
//# sourceMappingURL=index.js.map