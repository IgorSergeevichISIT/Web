var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/collection.ts
import { hasProp, isEqual, isObject } from "@zag-js/utils";
var fallback = {
  itemToValue(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "value")) return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string") return item;
    if (isObject(item) && hasProp(item, "label")) return item.label;
    return fallback.itemToValue(item);
  },
  isItemDisabled(item) {
    if (isObject(item) && hasProp(item, "disabled")) return !!item.disabled;
    return false;
  }
};
var Collection = class {
  constructor(options) {
    this.options = options;
    /**
     * The items in the collection
     */
    __publicField(this, "items");
    this.items = [...options.items];
  }
  isEqual(other) {
    return isEqual(this.items, other.items);
  }
  /**
   * Function to update the collection items
   */
  setItems(items) {
    this.items = Array.from(items);
  }
  /**
   * Returns all the values in the collection
   */
  getValues(items = this.items) {
    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);
  }
  /**
   * Get the item based on its value
   */
  find(value) {
    if (value == null) return null;
    const index = this.items.findIndex((item) => this.getItemValue(item) === value);
    return index != null ? this.items[index] : null;
  }
  /**
   * Get the items based on its values
   */
  findMany(values) {
    return Array.from(values).map((value) => this.find(value)).filter(Boolean);
  }
  /**
   * Get the item based on its index
   */
  at(index) {
    return this.items[index] ?? null;
  }
  sortFn(valueA, valueB) {
    const indexA = this.indexOf(valueA);
    const indexB = this.indexOf(valueB);
    return (indexA ?? 0) - (indexB ?? 0);
  }
  /**
   * Sort the values based on their index
   */
  sort(values) {
    return [...values].sort(this.sortFn.bind(this));
  }
  /**
   * Convert an item to a value
   */
  getItemValue(item) {
    if (item == null) return null;
    return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);
  }
  /**
   * Whether an item is disabled
   */
  getItemDisabled(item) {
    if (item == null) return false;
    return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);
  }
  /**
   * Convert an item to a string
   */
  stringifyItem(item) {
    if (item == null) return null;
    return this.options.itemToString?.(item) ?? fallback.itemToString(item);
  }
  /**
   * Convert a value to a string
   */
  stringify(value) {
    if (value == null) return null;
    return this.stringifyItem(this.find(value));
  }
  /**
   * Convert an array of items to a string
   */
  stringifyItems(items, separator = ", ") {
    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);
  }
  /**
   * Convert an array of items to a string
   */
  stringifyMany(value, separator) {
    return this.stringifyItems(this.findMany(value), separator);
  }
  /**
   * Whether the collection has a value
   */
  has(value) {
    return this.indexOf(value) !== -1;
  }
  /**
   * Whether the collection has an item
   */
  hasItem(item) {
    if (item == null) return false;
    return this.has(this.getItemValue(item));
  }
  /**
   * Returns the number of items in the collection
   */
  get size() {
    return this.items.length;
  }
  /**
   * Returns the first value in the collection
   */
  get firstValue() {
    let index = 0;
    while (this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the last value in the collection
   */
  get lastValue() {
    let index = this.size - 1;
    while (this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the next value in the collection
   */
  getNextValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index++;
    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
    return this.getItemValue(this.at(index));
  }
  /**
   * Returns the previous value in the collection
   */
  getPreviousValue(value) {
    let index = this.indexOf(value);
    if (index === -1) return null;
    index--;
    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
    return this.getItemValue(this.at(index));
  }
  /**
   * Get the index of an item based on its key
   */
  indexOf(value) {
    if (value == null) return -1;
    return this.items.findIndex((item) => this.getItemValue(item) === value);
  }
  getByText(text, current) {
    let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;
    const isSingleKey = text.length === 1;
    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);
    return items.find((item) => match(this.stringifyItem(item), text));
  }
  /**
   * Search for a value based on a query
   */
  search(queryString, options) {
    const { state, currentValue, timeout = 350 } = options;
    const search = state.keysSoFar + queryString;
    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
    const query = isRepeated ? search[0] : search;
    const item = this.getByText(query, currentValue);
    const value = this.getItemValue(item);
    function cleanup() {
      clearTimeout(state.timer);
      state.timer = -1;
    }
    function update(value2) {
      state.keysSoFar = value2;
      cleanup();
      if (value2 !== "") {
        state.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return value;
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  insertBefore(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index, 0, item);
  }
  insertAfter(value, item) {
    const index = this.indexOf(value);
    if (index === -1) return;
    this.items.splice(index + 1, 0, item);
  }
  reorder(fromIndex, toIndex) {
    if (fromIndex === -1 || toIndex === -1) return;
    if (fromIndex === toIndex) return;
    const [removed] = this.items.splice(fromIndex, 1);
    this.items.splice(toIndex, 0, removed);
  }
  toJSON() {
    return {
      size: this.size,
      first: this.firstValue,
      last: this.lastValue
    };
  }
};
var match = (label, query) => {
  return !!label?.toLowerCase().startsWith(query.toLowerCase());
};
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
export {
  Collection
};
//# sourceMappingURL=index.mjs.map