type Booleanish = boolean | "true" | "false";

declare const dataAttr: (guard: boolean | undefined) => Booleanish;
declare const ariaAttr: (guard: boolean | undefined) => "true" | undefined;

declare const MAX_Z_INDEX = 2147483647;

type Target = HTMLElement | EventTarget | null | undefined;
declare function contains(parent: Target, child: Target): boolean;

type DataUrlType = "image/png" | "image/jpeg" | "image/svg+xml";
interface DataUrlOptions {
    type: DataUrlType;
    quality?: number;
}
declare function getDataUrl(svg: SVGElement | undefined | null, opts: DataUrlOptions): Promise<string>;

declare function getDocument(el: Element | Window | Node | Document | null | undefined): Document;
declare function getDocumentElement(el: Element | Node | Window | Document | null | undefined): HTMLElement;
declare function getWindow(el: Node | ShadowRoot | Document | null | undefined): Window & typeof globalThis;
declare function getActiveElement(rootNode: Document | ShadowRoot): HTMLElement | null;

declare function getBeforeInputValue(event: Pick<InputEvent, "currentTarget">): string;
declare function getEventTarget<T extends EventTarget>(event: Partial<Pick<UIEvent, "target" | "composedPath">>): T | null;
declare const isSelfTarget: (event: Partial<Pick<UIEvent, "currentTarget" | "target" | "composedPath">>) => boolean;
declare function isOpeningInNewTab(event: Pick<MouseEvent, "currentTarget" | "metaKey" | "ctrlKey">): boolean;
declare function isDownloadingEvent(event: Pick<MouseEvent, "altKey" | "currentTarget">): boolean;
declare function isComposingEvent(event: any): any;

type ItemToId<T> = (v: T) => string;
declare const defaultItemToId: <T extends HTMLElement>(v: T) => string;
declare function itemById<T extends HTMLElement>(v: T[], id: string, itemToId?: ItemToId<T>): T | undefined;
declare function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId?: ItemToId<T>): number;
declare function nextById<T extends HTMLElement>(v: T[], id: string, loop?: boolean): T;
declare function prevById<T extends HTMLElement>(v: T[], id: string, loop?: boolean): T | null;

declare function getByText<T extends HTMLElement>(v: T[], text: string, currentId?: string | null, itemToId?: ItemToId<T>): T | undefined;

interface TypeaheadState {
    keysSoFar: string;
    timer: number;
}
interface TypeaheadOptions {
    state: TypeaheadState;
    activeId: string | null;
    key: string;
    timeout?: number;
    itemToId?: ItemToId<HTMLElement>;
}
declare function getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions): T | undefined;
declare const getByTypeahead: typeof getByTypeaheadImpl & {
    defaultOptions: {
        keysSoFar: string;
        timer: number;
    };
    isValidEvent: typeof isValidTypeaheadEvent;
};
declare function isValidTypeaheadEvent(event: Pick<KeyboardEvent, "key" | "ctrlKey" | "metaKey">): boolean;

declare function getComputedStyle(el: Element): CSSStyleDeclaration;

declare function getParentNode(node: Node): Node;

interface ScrollPosition {
    scrollLeft: number;
    scrollTop: number;
}
declare function getScrollPosition(element: HTMLElement | Window): ScrollPosition;

interface InitialFocusOptions {
    root: HTMLElement | null;
    getInitialEl?: () => HTMLElement | null;
    enabled?: boolean;
    filter?: (el: HTMLElement) => boolean;
}
declare function getInitialFocus(options: InitialFocusOptions): HTMLElement | undefined;
declare function isValidTabEvent(event: Pick<KeyboardEvent, "shiftKey" | "currentTarget">): boolean;

declare const isHTMLElement: (el: any) => el is HTMLElement;
declare const isDocument: (el: any) => el is Document;
declare const isWindow: (el: any) => el is Window;
declare const isVisualViewport: (el: any) => el is VisualViewport;
declare const getNodeName: (node: Node | Window) => string;
declare function isRootElement(node: Node): boolean;
declare const isNode: (el: any) => el is Node;
declare const isShadowRoot: (el: any) => el is ShadowRoot;

declare function isEditableElement(el: HTMLElement | EventTarget | null): boolean;

declare function isHiddenElement(node: HTMLElement): boolean;

declare function isOverflowElement(el: HTMLElement): boolean;

type MaybeElement$2 = HTMLElement | null;
type NodeOrFn$2 = MaybeElement$2 | (() => MaybeElement$2);
interface ObserveAttributeOptions {
    attributes: string[];
    callback(record: MutationRecord): void;
    defer?: boolean;
}
declare function observeAttributes(nodeOrFn: NodeOrFn$2, options: ObserveAttributeOptions): () => void;

type MaybeElement$1 = HTMLElement | null;
type NodeOrFn$1 = MaybeElement$1 | (() => MaybeElement$1);
interface ObserveChildrenOptions {
    callback: MutationCallback;
    defer?: boolean;
}
declare function observeChildren(nodeOrFn: NodeOrFn$1, options: ObserveChildrenOptions): () => void;

type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>;
declare function getNearestOverflowAncestor(el: Node): HTMLElement;
declare function getOverflowAncestors(el: HTMLElement, list?: OverflowAncestor): OverflowAncestor;
declare function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport): boolean;

declare const isDom: () => boolean;
declare function getPlatform(): any;
declare const isTouchDevice: () => boolean;
declare const isMac: () => boolean;
declare const isSafari: () => boolean;
declare const isFirefox: () => boolean;
declare const isApple: () => boolean;
declare const isIos: () => boolean;
declare const isWebKit: () => boolean;

type MaybeElement = HTMLElement | null;
type NodeOrFn = MaybeElement | (() => MaybeElement);
interface ProxyTabFocusOptions<T = MaybeElement> {
    triggerElement?: T;
    onFocus?: (elementToFocus: HTMLElement) => void;
    defer?: boolean;
}
declare function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>): () => void;

type Root = Document | Element | null | undefined;
declare function queryAll<T extends Element = HTMLElement>(root: Root, selector: string): T[];
declare function query<T extends Element = HTMLElement>(root: Root, selector: string): T | null;

declare function nextTick(fn: VoidFunction): () => void;
declare function raf(fn: VoidFunction): () => void;

interface ScopeContext {
    getRootNode?(): Document | ShadowRoot | Node;
}
declare function createScope<T>(methods: T): {
    getRootNode: (ctx: ScopeContext) => Document | ShadowRoot;
    getDoc: (ctx: ScopeContext) => Document;
    getWin: (ctx: ScopeContext) => Window & typeof globalThis;
    getActiveElement: (ctx: ScopeContext) => HTMLElement | null;
    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => boolean;
    getById: <T_1 extends Element = HTMLElement>(ctx: ScopeContext, id: string) => T_1 | null;
    setValue: <T_1 extends {
        value: string;
    }>(elem: T_1 | null, value: string | number | null | undefined) => void;
} & T;

interface ScrollOptions extends ScrollIntoViewOptions {
    rootEl: HTMLElement | null;
}
declare function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void;

declare function set(element: Element, key: string, setup: () => () => void): () => void;
declare function setAttribute(element: Element, attr: string, value: string): () => void;
declare function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]): () => void;
declare function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>): () => void;

type IncludeContainerType = boolean | "if-empty";
/**
 * Returns the focusable elements within the element
 */
declare const getFocusables: (container: Pick<HTMLElement, "querySelectorAll"> | null, includeContainer?: IncludeContainerType) => HTMLElement[];
/**
 * Whether this element is focusable
 */
declare function isFocusable(element: HTMLElement | null): element is HTMLElement;
declare function getFirstFocusable(container: HTMLElement | null, includeContainer?: IncludeContainerType): HTMLElement | null;
/**
 * Returns the tabbable elements within the element
 */
declare function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType): HTMLElement[];
/**
 * Whether this element is tabbable
 */
declare function isTabbable(el: HTMLElement | null): el is HTMLElement;
/**
 * Returns the first focusable element within the element
 */
declare function getFirstTabbable(container: HTMLElement | null, includeContainer?: IncludeContainerType): HTMLElement | null;
/**
 * Returns the last focusable element within the element
 */
declare function getLastTabbable(container: HTMLElement | null, includeContainer?: IncludeContainerType): HTMLElement | null;
/**
 * Returns the first and last focusable elements within the element
 */
declare function getTabbableEdges(container: HTMLElement | null, includeContainer?: IncludeContainerType): [HTMLElement, HTMLElement] | [null, null];
/**
 * Returns the next tabbable element after the current element
 */
declare function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null;

declare const visuallyHiddenStyle: {
    readonly border: "0";
    readonly clip: "rect(0 0 0 0)";
    readonly height: "1px";
    readonly margin: "-1px";
    readonly overflow: "hidden";
    readonly padding: "0";
    readonly position: "absolute";
    readonly width: "1px";
    readonly whiteSpace: "nowrap";
    readonly wordWrap: "normal";
};

type ElementGetter = () => Element | null;
declare function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void): () => void;
declare function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void): () => void;

export { type DataUrlOptions, type DataUrlType, type InitialFocusOptions, type ItemToId, MAX_Z_INDEX, type ObserveAttributeOptions, type ObserveChildrenOptions, type OverflowAncestor, type ScopeContext, type ScrollOptions, type ScrollPosition, type TypeaheadOptions, type TypeaheadState, ariaAttr, contains, createScope, dataAttr, defaultItemToId, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getDataUrl, getDocument, getDocumentElement, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getScrollPosition, getTabbableEdges, getTabbables, getWindow, indexOfId, isApple, isComposingEvent, isDocument, isDom, isDownloadingEvent, isEditableElement, isFirefox, isFocusable, isHTMLElement, isHiddenElement, isInView, isIos, isMac, isNode, isOpeningInNewTab, isOverflowElement, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isValidTabEvent, isVisualViewport, isWebKit, isWindow, itemById, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, raf, scrollIntoView, set, setAttribute, setProperty, setStyle, visuallyHiddenStyle, waitForElement, waitForElements };
