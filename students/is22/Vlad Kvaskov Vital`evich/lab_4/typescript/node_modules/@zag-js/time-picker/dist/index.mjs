// src/time-picker.anatomy.ts
import { createAnatomy } from "@zag-js/anatomy";
var anatomy = createAnatomy("time-picker").parts(
  "cell",
  "clearTrigger",
  "column",
  "content",
  "control",
  "input",
  "label",
  "positioner",
  "root",
  "spacer",
  "trigger"
);
var parts = anatomy.build();

// src/time-picker.connect.ts
import { getEventKey } from "@zag-js/dom-event";
import { ariaAttr, dataAttr, isComposingEvent } from "@zag-js/dom-query";
import { getPlacementStyles } from "@zag-js/popper";

// src/time-picker.dom.ts
import { createScope, query, queryAll } from "@zag-js/dom-query";
var dom = createScope({
  getContentId: (ctx) => ctx.ids?.content ?? `time-picker:${ctx.id}:content`,
  getColumnId: (ctx, unit) => ctx.ids?.column?.(unit) ?? `time-picker:${ctx.id}:column:${unit}`,
  getControlId: (ctx) => ctx.ids?.control ?? `time-picker:${ctx.id}:control`,
  getClearTriggerId: (ctx) => ctx.ids?.clearTrigger ?? `time-picker:${ctx.id}:clear-trigger`,
  getPositionerId: (ctx) => ctx.ids?.positioner ?? `time-picker:${ctx.id}:positioner`,
  getInputId: (ctx) => ctx.ids?.input ?? `time-picker:${ctx.id}:input`,
  getTriggerId: (ctx) => ctx.ids?.trigger ?? `time-picker:${ctx.id}:trigger`,
  getContentEl: (ctx) => dom.getById(ctx, dom.getContentId(ctx)),
  getColumnEl: (ctx, unit) => query(dom.getContentEl(ctx), `[data-part=column][data-unit=${unit}]`),
  getColumnEls: (ctx) => queryAll(dom.getContentEl(ctx), `[data-part=column]:not([hidden])`),
  getColumnCellEls: (ctx, unit) => queryAll(dom.getColumnEl(ctx, unit), `[data-part=cell]`),
  getControlEl: (ctx) => dom.getById(ctx, dom.getControlId(ctx)),
  getClearTriggerEl: (ctx) => dom.getById(ctx, dom.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx)),
  getTriggerEl: (ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),
  getFocusedCell: (ctx) => query(dom.getContentEl(ctx), `[data-part=cell][data-focus]`),
  getInitialFocusCell: (ctx, unit) => {
    const contentEl = dom.getContentEl(ctx);
    let cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);
    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));
    cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}]`));
    return cellEl;
  },
  getColumnUnit: (el) => el.dataset.unit,
  getCellValue: (el) => {
    const value = el?.dataset.value;
    return el?.dataset.unit === "period" ? value : Number(value ?? "0");
  }
});

// src/time-picker.utils.ts
import { Time } from "@internationalized/date";
function getCurrentTime() {
  const now = /* @__PURE__ */ new Date();
  return new Time(now.getHours(), now.getMinutes(), now.getSeconds());
}
var padStart = (value) => value.toString().padStart(2, "0");
function getStringifiedValue(ctx) {
  if (!ctx.value) return "";
  let hourValue = ctx.value.hour;
  if (ctx.hour12 && hourValue === 0) {
    hourValue = 12;
  } else if (ctx.hour12 && hourValue > 12) {
    hourValue -= 12;
  }
  let result = `${padStart(hourValue)}:${padStart(ctx.value.minute)}`;
  if (ctx.allowSeconds) {
    const second = padStart(ctx.value.second);
    result += `:${second}`;
  }
  if (ctx.hour12 && ctx.period) {
    result += ` ${ctx.period.toUpperCase()}`;
  }
  return result;
}
var TIME_REX = /(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?\s?(AM|PM|am|pm)?/;
function getTimeValue(ctx, value) {
  const match2 = value.match(TIME_REX);
  if (!match2) return;
  let [, hourString, minuteString, secondString, periodString] = match2;
  let hour = parseInt(hourString);
  const minute = parseInt(minuteString);
  const second = secondString ? parseInt(secondString) : void 0;
  if (!is12HourFormat(ctx.locale) && ctx.period) {
    return { time: new Time(hour, minute, second), period: ctx.period };
  }
  let period = periodString ? periodString.toLowerCase() : "am";
  if (hour > 11) {
    period = "pm";
  } else if (period === "pm") {
    hour += 12;
  }
  return { time: new Time(hour, minute, second), period };
}
function get12HourFormatPeriodHour(hour, period) {
  if (!period) return hour;
  return period === "pm" ? hour + 12 : hour;
}
function getHourPeriod(hour) {
  if (hour === void 0) return null;
  return hour > 11 ? "pm" : "am";
}
function is12HourFormat(locale) {
  return new Intl.DateTimeFormat(locale, { hour: "numeric" }).formatToParts(/* @__PURE__ */ new Date()).some((part) => part.type === "dayPeriod");
}
function getInputPlaceholder(ctx) {
  if (ctx.placeholder) return ctx.placeholder;
  const secondsPart = ctx.allowSeconds ? ":ss" : "";
  const periodPart = is12HourFormat(ctx.locale) ? " aa" : "";
  return `hh:mm${secondsPart}${periodPart}`;
}
function clampTime(value, min, max) {
  let time = value;
  if (min && min.compare(value) > 0) {
    time = min.copy();
  } else if (max && max.compare(value) < 0) {
    time = max.copy();
  }
  return time;
}

// src/time-picker.connect.ts
function connect(state, send, normalize) {
  const disabled = state.context.disabled;
  const readOnly = state.context.readOnly;
  const locale = state.context.locale;
  const hour12 = is12HourFormat(locale);
  const min = state.context.min;
  const max = state.context.max;
  const steps = state.context.steps;
  const focused = state.matches("focused");
  const open = state.hasTag("open");
  const value = state.context.value;
  const valueAsString = state.context.valueAsString;
  const currentTime = state.context.currentTime;
  const currentPlacement = state.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state.context.positioning,
    placement: state.context.currentPlacement
  });
  return {
    focused,
    open,
    value,
    valueAsString,
    hour12,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setOpen(nextOpen) {
      if (nextOpen === open) return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setUnitValue(unit, value2) {
      send({ type: "UNIT.SET", unit, value: value2 });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    getHours() {
      const length = hour12 ? 12 : 24;
      const arr = Array.from({ length }, (_, i) => i);
      const step = steps?.hour;
      const hours = step != null ? arr.filter((hour) => hour % step === 0) : arr;
      return hours.map((value2) => ({ label: hour12 && value2 === 0 ? "12" : padStart(value2), value: value2 }));
    },
    getMinutes() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps?.minute;
      const minutes = step != null ? arr.filter((minute) => minute % step === 0) : arr;
      return minutes.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getSeconds() {
      const arr = Array.from({ length: 60 }, (_, i) => i);
      const step = steps?.second;
      const seconds = step != null ? arr.filter((second) => second % step === 0) : arr;
      return seconds.map((value2) => ({ label: padStart(value2), value: value2 }));
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts.label.attrs,
        dir: state.context.dir,
        htmlFor: dom.getInputId(state.context),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        dir: state.context.dir,
        id: dom.getControlId(state.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts.input.attrs,
        dir: state.context.dir,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        id: dom.getInputId(state.context),
        name: state.context.name,
        defaultValue: valueAsString,
        placeholder: getInputPlaceholder(state.context),
        disabled,
        readOnly,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur(event) {
          const { value: value2 } = event.target;
          send({ type: "INPUT.BLUR", value: value2 });
        },
        onKeyDown(event) {
          if (isComposingEvent(event)) return;
          if (event.key !== "Enter") return;
          send({ type: "INPUT.ENTER", value: event.currentTarget.value });
          event.preventDefault();
        }
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts.trigger.attrs,
        id: dom.getTriggerId(state.context),
        type: "button",
        "data-placement": state.context.currentPlacement,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": open ? "Close calendar" : "Open calendar",
        "aria-controls": dom.getContentId(state.context),
        "data-state": open ? "open" : "closed",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("TRIGGER.CLICK");
        }
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts.clearTrigger.attrs,
        id: dom.getClearTriggerId(state.context),
        type: "button",
        hidden: !state.context.value,
        disabled,
        "data-readonly": dataAttr(readOnly),
        "aria-label": "Clear time",
        onClick(event) {
          if (event.defaultPrevented) return;
          send("VALUE.CLEAR");
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts.positioner.attrs,
        dir: state.context.dir,
        id: dom.getPositionerId(state.context),
        style: popperStyles.floating
      });
    },
    getSpacerProps() {
      return normalize.element({
        ...parts.spacer.attrs
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts.content.attrs,
        dir: state.context.dir,
        id: dom.getContentId(state.context),
        hidden: !open,
        tabIndex: 0,
        role: "application",
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        "aria-roledescription": "timepicker",
        "aria-label": "timepicker",
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (isComposingEvent(event)) return;
          const keyMap = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "CONTENT.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "CONTENT.ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "CONTENT.ENTER" });
            },
            // prevent tabbing out of the time picker
            Tab() {
            },
            Escape() {
              if (!state.context.disableLayer) return;
              send({ type: "CONTENT.ESCAPE" });
            }
          };
          const exec = keyMap[getEventKey(event, state.context)];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    },
    getColumnProps(props2) {
      const hidden = props2.unit === "second" && !state.context.allowSeconds || props2.unit === "period" && !hour12;
      return normalize.element({
        ...parts.column.attrs,
        id: dom.getColumnId(state.context, props2.unit),
        "data-unit": props2.unit,
        "data-focus": dataAttr(state.context.focusedColumn === props2.unit),
        hidden
      });
    },
    getHourCellProps(props2) {
      const hour = props2.value;
      const isSelectable = !(min && get12HourFormatPeriodHour(hour, state.context.period) < min.hour || max && get12HourFormatPeriodHour(hour, state.context.period) > max.hour);
      const isSelected = state.context.value?.hour === get12HourFormatPeriodHour(hour, state.context.period);
      const isFocused = state.context.focusedColumn === "hour" && state.context.focusedValue === hour;
      const currentHour = hour12 && currentTime ? currentTime?.hour % 12 : currentTime?.hour;
      const isCurrent = currentHour === hour || hour === 12 && currentHour === 0;
      return normalize.button({
        ...parts.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "aria-label": `${hour} hours`,
        "data-value": hour,
        "data-unit": "hour",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "hour", value: hour });
        }
      });
    },
    getMinuteCellProps(props2) {
      const minute = props2.value;
      const { value: value2 } = state.context;
      const minMinute = min?.set({ second: 0 });
      const maxMinute = max?.set({ second: 0 });
      const isSelectable = !(minMinute && value2 && minMinute.compare(value2.set({ minute })) > 0 || maxMinute && value2 && maxMinute.compare(value2.set({ minute })) < 0);
      const isSelected = state.context.value?.minute === minute;
      const isCurrent = currentTime?.minute === minute;
      const isFocused = state.context.focusedColumn === "minute" && state.context.focusedValue === minute;
      return normalize.button({
        ...parts.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${minute} minutes`,
        "data-value": minute,
        "data-now": dataAttr(isCurrent),
        "data-focus": dataAttr(isFocused),
        "data-unit": "minute",
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "minute", value: minute });
        }
      });
    },
    getSecondCellProps(props2) {
      const second = props2.value;
      const isSelectable = !(min && value?.minute && min.compare(value.set({ second })) > 0 || max && value?.minute && max.compare(value.set({ second })) < 0);
      const isSelected = state.context.value?.second === second;
      const isCurrent = currentTime?.second === second;
      const isFocused = state.context.focusedColumn === "second" && state.context.focusedValue === second;
      return normalize.button({
        ...parts.cell.attrs,
        type: "button",
        "aria-disabled": ariaAttr(!isSelectable),
        "data-disabled": dataAttr(!isSelectable),
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "aria-label": `${second} seconds`,
        "data-value": second,
        "data-unit": "second",
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (!isSelectable) return;
          send({ type: "UNIT.CLICK", unit: "second", value: second });
        }
      });
    },
    getPeriodCellProps(props2) {
      const isSelected = state.context.period === props2.value;
      const currentPeriod = getHourPeriod(currentTime?.hour);
      const isCurrent = currentPeriod === props2.value;
      const isFocused = state.context.focusedColumn === "period" && state.context.focusedValue === props2.value;
      return normalize.button({
        ...parts.cell.attrs,
        type: "button",
        "aria-current": ariaAttr(isSelected),
        "data-selected": dataAttr(isSelected),
        "data-focus": dataAttr(isFocused),
        "data-now": dataAttr(isCurrent),
        "aria-label": props2.value,
        "data-value": props2.value,
        "data-unit": "period",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "UNIT.CLICK", unit: "period", value: props2.value });
        }
      });
    }
  };
}

// src/time-picker.machine.ts
import { Time as Time2 } from "@internationalized/date";
import { createMachine, guards } from "@zag-js/core";
import { trackDismissableElement } from "@zag-js/dismissable";
import { raf } from "@zag-js/dom-query";
import { getPlacement } from "@zag-js/popper";
import { compact, isEqual, match, next, prev } from "@zag-js/utils";
var { and } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "time-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        value: null,
        locale: "en-US",
        ...ctx,
        focusedColumn: "hour",
        focusedValue: null,
        currentTime: null,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        valueAsString: (ctx2) => getStringifiedValue(ctx2),
        hour12: (ctx2) => is12HourFormat(ctx2.locale),
        period: (ctx2) => getHourPeriod(ctx2.value?.hour)
      },
      watch: {
        open: ["toggleVisibility"],
        value: ["syncInputElement"],
        period: ["syncInputElement"],
        focusedColumn: ["syncFocusedValue"],
        focusedValue: ["focusCell"]
      },
      on: {
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "UNIT.SET": {
          actions: ["setUnitValue"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "INPUT.FOCUS": {
              target: "focused"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        focused: {
          tags: ["closed"],
          on: {
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setInputValue", "clampTimeValue"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: ["setInputValue", "clampTimeValue"]
            },
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["setCurrentTime", "scrollColumnsToTop", "focusHourColumn"],
          exit: ["resetFocusedCell"],
          activities: ["computePlacement", "trackDismissableElement"],
          on: {
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "INPUT.ENTER": {
              actions: ["setInputValue", "clampTimeValue"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "CONTROLLED.CLOSE": [
              {
                guard: and("shouldRestoreFocus", "isInteractOutsideEvent"),
                target: "focused",
                actions: ["focusTriggerElement"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["focusInputElement"]
              },
              {
                target: "idle"
              }
            ],
            "CONTENT.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "focusInputElement"]
              }
            ],
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "focusTriggerElement"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: ["reposition"]
            },
            "UNIT.CLICK": {
              actions: ["setFocusedValue", "setFocusedColumn", "setUnitValue"]
            },
            "CONTENT.ARROW_UP": {
              actions: ["focusPreviousCell"]
            },
            "CONTENT.ARROW_DOWN": {
              actions: ["focusNextCell"]
            },
            "CONTENT.ARROW_LEFT": {
              actions: ["focusPreviousColumnCell"]
            },
            "CONTENT.ARROW_RIGHT": {
              actions: ["focusNextColumnCell"]
            },
            "CONTENT.ENTER": {
              actions: ["selectFocusedCell", "focusNextColumnCell"]
            }
          }
        }
      }
    },
    {
      guards: {
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isInteractOutsideEvent: (_ctx, evt) => evt.previousEvent?.type === "INTERACT_OUTSIDE"
      },
      activities: {
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = () => dom.getControlEl(ctx2);
          const positionerEl = () => dom.getPositionerEl(ctx2);
          return getPlacement(anchorEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          if (ctx2.disableLayer) return;
          return trackDismissableElement(dom.getContentEl(ctx2), {
            defer: true,
            exclude: [dom.getTriggerEl(ctx2), dom.getClearTriggerEl(ctx2)],
            onEscapeKeyDown(event) {
              event.preventDefault();
              ctx2.restoreFocus = true;
              send({ type: "CONTENT.ESCAPE" });
            },
            onInteractOutside(event) {
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom.getPositionerEl(ctx2);
          getPlacement(dom.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        invokeOnOpen(ctx2) {
          ctx2.onOpenChange?.({ open: true });
        },
        invokeOnClose(ctx2) {
          ctx2.onOpenChange?.({ open: false });
        },
        setInputValue(ctx2, evt) {
          const timeValue = getTimeValue(ctx2, evt.value);
          if (!timeValue) return;
          set.value(ctx2, timeValue.time);
        },
        syncInputElement(ctx2) {
          const inputEl = dom.getInputEl(ctx2);
          if (!inputEl) return;
          inputEl.value = ctx2.valueAsString;
        },
        setUnitValue(ctx2, evt) {
          const { unit, value } = evt;
          const current = ctx2.value ?? ctx2.currentTime ?? new Time2(0);
          const nextTime = match(unit, {
            hour: () => current.set({ hour: ctx2.hour12 ? value + 12 : value }),
            minute: () => current.set({ minute: value }),
            second: () => current.set({ second: value }),
            period: () => {
              if (!ctx2.value) return;
              const diff = value === "pm" ? 12 : 0;
              return ctx2.value.set({ hour: ctx2.value.hour % 12 + diff });
            }
          });
          if (!nextTime) return;
          set.value(ctx2, nextTime);
        },
        setValue(ctx2, evt) {
          if (!(evt.value instanceof Time2)) return;
          set.value(ctx2, evt.value);
        },
        clearValue(ctx2) {
          set.value(ctx2, null);
        },
        setFocusedValue(ctx2, evt) {
          set.focusedValue(ctx2, evt.value);
        },
        setFocusedColumn(ctx2, evt) {
          set.focusedColumn(ctx2, evt.unit);
        },
        resetFocusedCell(ctx2) {
          set.focusedColumn(ctx2, "hour");
          set.focusedValue(ctx2, null);
        },
        clampTimeValue(ctx2) {
          if (!ctx2.value) return;
          const nextTime = clampTime(ctx2.value, ctx2.min, ctx2.max);
          set.value(ctx2, nextTime);
        },
        setCurrentTime(ctx2) {
          ctx2.currentTime = getCurrentTime();
        },
        scrollColumnsToTop(ctx2) {
          raf(() => {
            const columnEls = dom.getColumnEls(ctx2);
            for (const columnEl of columnEls) {
              const cellEl = dom.getInitialFocusCell(ctx2, columnEl.dataset.unit);
              if (!cellEl) continue;
              columnEl.scrollTop = cellEl.offsetTop - 4;
            }
          });
        },
        focusTriggerElement(ctx2) {
          dom.getTriggerEl(ctx2)?.focus({ preventScroll: true });
        },
        focusInputElement(ctx2) {
          dom.getInputEl(ctx2)?.focus({ preventScroll: true });
        },
        focusHourColumn(ctx2) {
          raf(() => {
            const hourEl = dom.getInitialFocusCell(ctx2, "hour");
            if (!hourEl) return;
            set.focusedValue(ctx2, dom.getCellValue(hourEl));
          });
        },
        focusPreviousCell(ctx2) {
          raf(() => {
            const cells = dom.getColumnCellEls(ctx2, ctx2.focusedColumn);
            const focusedEl = dom.getFocusedCell(ctx2);
            const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
            const prevCell = prev(cells, focusedIndex, { loop: false });
            if (!prevCell) return;
            set.focusedValue(ctx2, dom.getCellValue(prevCell));
          });
        },
        focusNextCell(ctx2) {
          raf(() => {
            const cells = dom.getColumnCellEls(ctx2, ctx2.focusedColumn);
            const focusedEl = dom.getFocusedCell(ctx2);
            const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;
            const nextCell = next(cells, focusedIndex, { loop: false });
            if (!nextCell) return;
            set.focusedValue(ctx2, dom.getCellValue(nextCell));
          });
        },
        selectFocusedCell(ctx2) {
          const current = ctx2.value ?? ctx2.currentTime ?? new Time2(0);
          let value = ctx2.focusedValue;
          let column = ctx2.focusedColumn;
          if (column === "hour" && ctx2.hour12) {
            value = ctx2.hour12 ? value + 12 : value;
          } else if (ctx2.focusedColumn === "period") {
            column = "hour";
            const diff = value === "pm" ? 12 : 0;
            value = current.hour % 12 + diff;
          }
          const nextTime = current.set({ [column]: value });
          set.value(ctx2, nextTime);
        },
        focusPreviousColumnCell(ctx2) {
          raf(() => {
            const columns = dom.getColumnEls(ctx2);
            const currentColumnEl = dom.getColumnEl(ctx2, ctx2.focusedColumn);
            const focusedIndex = columns.indexOf(currentColumnEl);
            const prevColumnEl = prev(columns, focusedIndex, { loop: false });
            if (!prevColumnEl) return;
            set.focusedColumn(ctx2, dom.getColumnUnit(prevColumnEl));
          });
        },
        focusNextColumnCell(ctx2) {
          raf(() => {
            const columns = dom.getColumnEls(ctx2);
            const currentColumnEl = dom.getColumnEl(ctx2, ctx2.focusedColumn);
            const focusedIndex = columns.indexOf(currentColumnEl);
            const nextColumnEl = next(columns, focusedIndex, { loop: false });
            if (!nextColumnEl) return;
            set.focusedColumn(ctx2, dom.getColumnUnit(nextColumnEl));
          });
        },
        focusCell(ctx2) {
          queueMicrotask(() => {
            const cellEl = dom.getFocusedCell(ctx2);
            cellEl?.focus();
          });
        },
        syncFocusedValue(ctx2) {
          if (ctx2.focusedValue === null) return;
          queueMicrotask(() => {
            const cellEl = dom.getInitialFocusCell(ctx2, ctx2.focusedColumn);
            set.focusedValue(ctx2, dom.getCellValue(cellEl));
          });
        }
      },
      compareFns: {
        value: isTimeEqual
      }
    }
  );
}
var isTimeEqual = (a, b) => {
  return a?.toString() === b?.toString();
};
var invoke = {
  change(ctx) {
    ctx.onValueChange?.({
      value: ctx.value,
      valueAsString: ctx.valueAsString
    });
  },
  focusChange(ctx) {
    ctx.onFocusChange?.({
      value: ctx.value,
      valueAsString: ctx.valueAsString,
      focusedValue: ctx.focusedValue,
      focusedUnit: ctx.focusedColumn
    });
  }
};
var set = {
  value(ctx, value) {
    if (isTimeEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value)) return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  },
  focusedColumn(ctx, column) {
    if (ctx.focusedColumn === column) return;
    ctx.focusedColumn = column;
  }
};

// src/time-picker.parse.ts
import { Time as Time3 } from "@internationalized/date";
function parse(value) {
  return new Time3(value.hour, value.minute, value.second, value.millisecond);
}

// src/time-picker.props.ts
import { createProps } from "@zag-js/types";
import { createSplitProps } from "@zag-js/utils";
var props = createProps()([
  "dir",
  "disabled",
  "disableLayer",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "open.controlled",
  "open",
  "placeholder",
  "positioning",
  "readOnly",
  "steps",
  "value",
  "allowSeconds"
]);
var splitProps = createSplitProps(props);
export {
  anatomy,
  connect,
  machine,
  parse,
  props,
  splitProps
};
//# sourceMappingURL=index.mjs.map