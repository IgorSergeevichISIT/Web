"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  alignCenter: () => alignCenter,
  alignDate: () => alignDate,
  alignEnd: () => alignEnd,
  alignStart: () => alignStart,
  alignStartDate: () => alignStartDate,
  constrainStart: () => constrainStart,
  constrainValue: () => constrainValue,
  formatRange: () => formatRange,
  formatSelectedDate: () => formatSelectedDate,
  formatVisibleRange: () => formatVisibleRange,
  getAdjustedDateFn: () => getAdjustedDateFn,
  getCustomWeeksInMonth: () => getCustomWeeksInMonth,
  getDateRangePreset: () => getDateRangePreset,
  getDayFormatter: () => getDayFormatter,
  getDaysInWeek: () => getDaysInWeek,
  getDecadeRange: () => getDecadeRange,
  getEndDate: () => getEndDate,
  getMonthDays: () => getMonthDays,
  getMonthFormatter: () => getMonthFormatter,
  getMonthNames: () => getMonthNames,
  getNextDay: () => getNextDay,
  getNextPage: () => getNextPage,
  getNextRow: () => getNextRow,
  getNextSection: () => getNextSection,
  getPreviousAvailableDate: () => getPreviousAvailableDate,
  getPreviousDay: () => getPreviousDay,
  getPreviousPage: () => getPreviousPage,
  getPreviousRow: () => getPreviousRow,
  getPreviousSection: () => getPreviousSection,
  getSectionEnd: () => getSectionEnd,
  getSectionStart: () => getSectionStart,
  getTodayDate: () => getTodayDate,
  getUnitDuration: () => getUnitDuration,
  getWeekDays: () => getWeekDays,
  getWeekdayFormats: () => getWeekdayFormats,
  getYearsRange: () => getYearsRange,
  isDateDisabled: () => isDateDisabled,
  isDateEqual: () => isDateEqual,
  isDateInvalid: () => isDateInvalid,
  isDateOutsideVisibleRange: () => isDateOutsideVisibleRange,
  isDateUnavailable: () => isDateUnavailable,
  isNextVisibleRangeInvalid: () => isNextVisibleRangeInvalid,
  isPreviousVisibleRangeInvalid: () => isPreviousVisibleRangeInvalid,
  isTodayDate: () => isTodayDate,
  parseDateString: () => parseDateString,
  setCalendar: () => setCalendar,
  setDate: () => setDate,
  setMonth: () => setMonth,
  setYear: () => setYear
});
module.exports = __toCommonJS(src_exports);

// src/constrain.ts
var import_date = require("@internationalized/date");
function alignCenter(date, duration, locale, min, max) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignStart(date, duration, locale, min, max) {
  let aligned = date;
  if (duration.years) {
    aligned = (0, import_date.startOfYear)(date);
  } else if (duration.months) {
    aligned = (0, import_date.startOfMonth)(date);
  } else if (duration.weeks) {
    aligned = (0, import_date.startOfWeek)(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function constrainStart(date, aligned, duration, locale, min, max) {
  if (min && date.compare(min) >= 0) {
    aligned = (0, import_date.maxDate)(aligned, alignStart((0, import_date.toCalendarDate)(min), duration, locale));
  }
  if (max && date.compare(max) <= 0) {
    aligned = (0, import_date.minDate)(aligned, alignEnd((0, import_date.toCalendarDate)(max), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  if (minValue) {
    date = (0, import_date.maxDate)(date, (0, import_date.toCalendarDate)(minValue));
  }
  if (maxValue) {
    date = (0, import_date.minDate)(date, (0, import_date.toCalendarDate)(maxValue));
  }
  return date;
}

// src/align.ts
function alignDate(date, alignment, duration, locale, min, max) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min, max);
    case "end":
      return alignEnd(date, duration, locale, min, max);
    case "center":
    default:
      return alignCenter(date, duration, locale, min, max);
  }
}
function alignStartDate(date, startDate, endDate, duration, locale, min, max) {
  if (date.compare(startDate) < 0) {
    return alignEnd(date, duration, locale, min, max);
  }
  if (date.compare(endDate) > 0) {
    return alignStart(date, duration, locale, min, max);
  }
  return startDate;
}

// src/assertion.ts
var import_date2 = require("@internationalized/date");
function isTodayDate(date, timeZone) {
  return (0, import_date2.isToday)(date, timeZone);
}
function isDateEqual(dateA, dateB) {
  return dateB != null && (0, import_date2.isSameDay)(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue) {
  return minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue) {
  return isDateOutsideVisibleRange(date, startDate, endDate) || isDateInvalid(date, minValue, maxValue);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue) {
  if (!date) {
    return false;
  }
  if (isUnavailable?.(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue) {
  const prevDate = startDate.subtract({ days: 1 });
  return (0, import_date2.isSameDay)(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue) {
  const nextDate = endDate.add({ days: 1 });
  return (0, import_date2.isSameDay)(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue);
}

// src/duration.ts
function getUnitDuration(duration) {
  let clone = { ...duration };
  for (let key in clone) {
    clone[key] = 1;
  }
  return clone;
}
function getEndDate(startDate, duration) {
  let clone = { ...duration };
  if (clone.days) {
    clone.days--;
  } else {
    clone.days = -1;
  }
  return startDate.add(clone);
}

// src/format-range.ts
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    let part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      start += parts[i].value;
    } else if (i > separatorIndex) {
      end += parts[i].value;
    }
  }
  return toString(start, end);
}

// src/format-selected-date.ts
var import_date4 = require("@internationalized/date");

// src/get-day-formatter.ts
var import_date3 = require("@internationalized/date");

// src/get-era-format.ts
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : void 0;
}

// src/get-day-formatter.ts
function getDayFormatter(locale, timeZone) {
  const date = (0, import_date3.toCalendarDateTime)((0, import_date3.today)(timeZone));
  return new import_date3.DateFormatter(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}

// src/format-selected-date.ts
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ((0, import_date4.isSameDay)(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2} \u2013 ${end2}`, timeZone);
}

// src/format-visible-range.ts
var import_date6 = require("@internationalized/date");

// src/get-month-formatter.ts
var import_date5 = require("@internationalized/date");
function getMonthFormatter(locale, timeZone) {
  const date = (0, import_date5.toCalendarDate)((0, import_date5.today)(timeZone));
  return new import_date5.DateFormatter(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date?.calendar.identifier,
    timeZone
  });
}

// src/format-visible-range.ts
function formatVisibleRange(startDate, endDate, locale, timeZone) {
  const start = startDate;
  const end = endDate ?? startDate;
  const dayFormatter = getDayFormatter(locale, timeZone);
  if (!(0, import_date6.isSameDay)(start, (0, import_date6.startOfMonth)(start))) {
    return dayFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  const monthFormatter = getMonthFormatter(locale, timeZone);
  if ((0, import_date6.isSameDay)(end, (0, import_date6.endOfMonth)(start))) {
    return monthFormatter.format(start.toDate(timeZone));
  }
  if ((0, import_date6.isSameDay)(end, (0, import_date6.endOfMonth)(end))) {
    return monthFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  return "";
}

// src/get-decade-range.ts
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}

// src/get-month-days.ts
var import_date8 = require("@internationalized/date");

// src/get-start-of-week.ts
var import_date7 = require("@internationalized/date");
function getStartOfWeek(date, locale, firstDayOfWeek = 0) {
  const day = (0, import_date7.getDayOfWeek)(date, locale);
  const diff = (day - firstDayOfWeek + 7) % 7;
  return date.subtract({ days: diff });
}

// src/get-month-days.ts
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ((0, import_date8.isSameDay)(date, nextDate)) {
      break;
    }
    date = nextDate;
  }
  return dates;
}
function getCustomWeeksInMonth(from, locale, firstDayOfWeek) {
  if (firstDayOfWeek == null) {
    return (0, import_date8.getWeeksInMonth)(from, locale);
  }
  const paddingDays = ((0, import_date8.getDayOfWeek)((0, import_date8.startOfMonth)(from), locale) - firstDayOfWeek + 7) % 7;
  return Math.ceil((paddingDays + from.calendar.getDaysInMonth(from)) / 7);
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const monthWeeks = numOfWeeks ?? getCustomWeeksInMonth(from, locale, firstDayOfWeek);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}

// src/get-month-names.ts
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}

// src/get-weekday-formats.ts
var import_date9 = require("@internationalized/date");
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new import_date9.DateFormatter(locale, { weekday: "long", timeZone });
  const shortFormat = new import_date9.DateFormatter(locale, { weekday: "short", timeZone });
  const narrowFormat = new import_date9.DateFormatter(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}

// src/get-week-days.ts
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}

// src/get-year-range.ts
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) {
    years.push(year);
  }
  return years;
}

// src/mutation.ts
var import_date10 = require("@internationalized/date");
function getTodayDate(timeZone) {
  return (0, import_date10.today)(timeZone ?? (0, import_date10.getLocalTimeZone)());
}
function getNextDay(date) {
  return date.add({ days: 1 });
}
function getPreviousDay(date) {
  return date.subtract({ days: 1 });
}
function setMonth(date, month) {
  return date.set({ month });
}
function setYear(date, year) {
  return date.set({ year });
}
function setCalendar(date, calendar) {
  return (0, import_date10.toCalendar)((0, import_date10.toCalendarDateTime)(date), calendar);
}
function setDate(date, startDate, isDateUnavailable2, locale, minValue, maxValue) {
  let result;
  result = constrainValue(date, minValue, maxValue);
  result = getPreviousAvailableDate(date, startDate, locale, isDateUnavailable2);
  return result;
}
function getPreviousAvailableDate(date, minValue, locale, isDateUnavailable2) {
  if (!isDateUnavailable2) {
    return date;
  }
  while (date.compare(minValue) >= 0 && isDateUnavailable2(date, locale)) {
    date = date.subtract({ days: 1 });
  }
  if (date.compare(minValue) >= 0) {
    return date;
  }
}

// src/pagination.ts
var import_date11 = require("@internationalized/date");
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue),
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  let start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ weeks: 1 }),
      startDate
    });
  }
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ weeks: 1 }),
      startDate
    });
  }
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: startDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: (0, import_date11.startOfWeek)(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: (0, import_date11.startOfMonth)(focusedDate),
      startDate
    });
  }
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const endDate = getEndDate(startDate, visibleDuration);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: endDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      //@ts-expect-error - endOfWeek is loosely typed
      focusedDate: (0, import_date11.endOfWeek)(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: (0, import_date11.endOfMonth)(focusedDate),
      startDate
    });
  }
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}

// src/parse-date.ts
var import_date12 = require("@internationalized/date");
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new import_date12.CalendarDate(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new import_date12.CalendarDate(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new import_date12.DateFormatter(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g)?.map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)?.[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}

// src/preset.ts
var import_date13 = require("@internationalized/date");
function getDateRangePreset(preset, locale, timeZone) {
  const today4 = (0, import_date13.now)(timeZone);
  switch (preset) {
    case "thisWeek":
      return [(0, import_date13.startOfWeek)(today4, locale), (0, import_date13.endOfWeek)(today4, locale)];
    case "thisMonth":
      return [(0, import_date13.startOfMonth)(today4), today4];
    case "thisQuarter":
      return [(0, import_date13.startOfMonth)(today4).add({ months: -today4.month % 3 }), today4];
    case "thisYear":
      return [(0, import_date13.startOfYear)(today4), today4];
    case "last3Days":
      return [today4.add({ days: -2 }), today4];
    case "last7Days":
      return [today4.add({ days: -6 }), today4];
    case "last14Days":
      return [today4.add({ days: -13 }), today4];
    case "last30Days":
      return [today4.add({ days: -29 }), today4];
    case "last90Days":
      return [today4.add({ days: -89 }), today4];
    case "lastMonth":
      return [(0, import_date13.startOfMonth)(today4.add({ months: -1 })), (0, import_date13.endOfMonth)(today4.add({ months: -1 }))];
    case "lastQuarter":
      return [
        (0, import_date13.startOfMonth)(today4.add({ months: -today4.month % 3 - 3 })),
        (0, import_date13.endOfMonth)(today4.add({ months: -today4.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [(0, import_date13.startOfWeek)(today4, locale).add({ weeks: -1 }), (0, import_date13.endOfWeek)(today4, locale).add({ weeks: -1 })];
    case "lastYear":
      return [(0, import_date13.startOfYear)(today4.add({ years: -1 })), (0, import_date13.endOfYear)(today4.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  alignCenter,
  alignDate,
  alignEnd,
  alignStart,
  alignStartDate,
  constrainStart,
  constrainValue,
  formatRange,
  formatSelectedDate,
  formatVisibleRange,
  getAdjustedDateFn,
  getCustomWeeksInMonth,
  getDateRangePreset,
  getDayFormatter,
  getDaysInWeek,
  getDecadeRange,
  getEndDate,
  getMonthDays,
  getMonthFormatter,
  getMonthNames,
  getNextDay,
  getNextPage,
  getNextRow,
  getNextSection,
  getPreviousAvailableDate,
  getPreviousDay,
  getPreviousPage,
  getPreviousRow,
  getPreviousSection,
  getSectionEnd,
  getSectionStart,
  getTodayDate,
  getUnitDuration,
  getWeekDays,
  getWeekdayFormats,
  getYearsRange,
  isDateDisabled,
  isDateEqual,
  isDateInvalid,
  isDateOutsideVisibleRange,
  isDateUnavailable,
  isNextVisibleRangeInvalid,
  isPreviousVisibleRangeInvalid,
  isTodayDate,
  parseDateString,
  setCalendar,
  setDate,
  setMonth,
  setYear
});
//# sourceMappingURL=index.js.map