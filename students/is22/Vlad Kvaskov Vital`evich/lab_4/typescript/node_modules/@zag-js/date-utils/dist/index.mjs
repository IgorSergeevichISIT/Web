// src/constrain.ts
import {
  maxDate,
  minDate,
  startOfMonth,
  startOfWeek,
  startOfYear,
  toCalendarDate
} from "@internationalized/date";
function alignCenter(date, duration, locale, min, max) {
  const halfDuration = {};
  for (let prop in duration) {
    const key = prop;
    const value = duration[key];
    if (value == null) continue;
    halfDuration[key] = Math.floor(value / 2);
    if (halfDuration[key] > 0 && value % 2 === 0) {
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignStart(date, duration, locale, min, max) {
  let aligned = date;
  if (duration.years) {
    aligned = startOfYear(date);
  } else if (duration.months) {
    aligned = startOfMonth(date);
  } else if (duration.weeks) {
    aligned = startOfWeek(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min, max);
}
function alignEnd(date, duration, locale, min, max) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min, max);
}
function constrainStart(date, aligned, duration, locale, min, max) {
  if (min && date.compare(min) >= 0) {
    aligned = maxDate(aligned, alignStart(toCalendarDate(min), duration, locale));
  }
  if (max && date.compare(max) <= 0) {
    aligned = minDate(aligned, alignEnd(toCalendarDate(max), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  if (minValue) {
    date = maxDate(date, toCalendarDate(minValue));
  }
  if (maxValue) {
    date = minDate(date, toCalendarDate(maxValue));
  }
  return date;
}

// src/align.ts
function alignDate(date, alignment, duration, locale, min, max) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min, max);
    case "end":
      return alignEnd(date, duration, locale, min, max);
    case "center":
    default:
      return alignCenter(date, duration, locale, min, max);
  }
}
function alignStartDate(date, startDate, endDate, duration, locale, min, max) {
  if (date.compare(startDate) < 0) {
    return alignEnd(date, duration, locale, min, max);
  }
  if (date.compare(endDate) > 0) {
    return alignStart(date, duration, locale, min, max);
  }
  return startDate;
}

// src/assertion.ts
import { isSameDay, isToday } from "@internationalized/date";
function isTodayDate(date, timeZone) {
  return isToday(date, timeZone);
}
function isDateEqual(dateA, dateB) {
  return dateB != null && isSameDay(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue) {
  return minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue) {
  return isDateOutsideVisibleRange(date, startDate, endDate) || isDateInvalid(date, minValue, maxValue);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue) {
  if (!date) {
    return false;
  }
  if (isUnavailable?.(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue) {
  const prevDate = startDate.subtract({ days: 1 });
  return isSameDay(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue) {
  const nextDate = endDate.add({ days: 1 });
  return isSameDay(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue);
}

// src/duration.ts
function getUnitDuration(duration) {
  let clone = { ...duration };
  for (let key in clone) {
    clone[key] = 1;
  }
  return clone;
}
function getEndDate(startDate, duration) {
  let clone = { ...duration };
  if (clone.days) {
    clone.days--;
  } else {
    clone.days = -1;
  }
  return startDate.add(clone);
}

// src/format-range.ts
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    let part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      start += parts[i].value;
    } else if (i > separatorIndex) {
      end += parts[i].value;
    }
  }
  return toString(start, end);
}

// src/format-selected-date.ts
import { isSameDay as isSameDay2 } from "@internationalized/date";

// src/get-day-formatter.ts
import { DateFormatter, toCalendarDateTime, today } from "@internationalized/date";

// src/get-era-format.ts
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : void 0;
}

// src/get-day-formatter.ts
function getDayFormatter(locale, timeZone) {
  const date = toCalendarDateTime(today(timeZone));
  return new DateFormatter(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}

// src/format-selected-date.ts
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if (isSameDay2(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2} \u2013 ${end2}`, timeZone);
}

// src/format-visible-range.ts
import { endOfMonth, isSameDay as isSameDay3, startOfMonth as startOfMonth2 } from "@internationalized/date";

// src/get-month-formatter.ts
import { today as today2, toCalendarDate as toCalendarDate2, DateFormatter as DateFormatter2 } from "@internationalized/date";
function getMonthFormatter(locale, timeZone) {
  const date = toCalendarDate2(today2(timeZone));
  return new DateFormatter2(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date?.calendar.identifier,
    timeZone
  });
}

// src/format-visible-range.ts
function formatVisibleRange(startDate, endDate, locale, timeZone) {
  const start = startDate;
  const end = endDate ?? startDate;
  const dayFormatter = getDayFormatter(locale, timeZone);
  if (!isSameDay3(start, startOfMonth2(start))) {
    return dayFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  const monthFormatter = getMonthFormatter(locale, timeZone);
  if (isSameDay3(end, endOfMonth(start))) {
    return monthFormatter.format(start.toDate(timeZone));
  }
  if (isSameDay3(end, endOfMonth(end))) {
    return monthFormatter.formatRange(start.toDate(timeZone), end.toDate(timeZone));
  }
  return "";
}

// src/get-decade-range.ts
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}

// src/get-month-days.ts
import { getWeeksInMonth, isSameDay as isSameDay4, getDayOfWeek as getDayOfWeek2, startOfMonth as startOfMonth3 } from "@internationalized/date";

// src/get-start-of-week.ts
import { getDayOfWeek } from "@internationalized/date";
function getStartOfWeek(date, locale, firstDayOfWeek = 0) {
  const day = getDayOfWeek(date, locale);
  const diff = (day - firstDayOfWeek + 7) % 7;
  return date.subtract({ days: diff });
}

// src/get-month-days.ts
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if (isSameDay4(date, nextDate)) {
      break;
    }
    date = nextDate;
  }
  return dates;
}
function getCustomWeeksInMonth(from, locale, firstDayOfWeek) {
  if (firstDayOfWeek == null) {
    return getWeeksInMonth(from, locale);
  }
  const paddingDays = (getDayOfWeek2(startOfMonth3(from), locale) - firstDayOfWeek + 7) % 7;
  return Math.ceil((paddingDays + from.calendar.getDaysInMonth(from)) / 7);
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const monthWeeks = numOfWeeks ?? getCustomWeeksInMonth(from, locale, firstDayOfWeek);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}

// src/get-month-names.ts
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}

// src/get-weekday-formats.ts
import { DateFormatter as DateFormatter3 } from "@internationalized/date";
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new DateFormatter3(locale, { weekday: "long", timeZone });
  const shortFormat = new DateFormatter3(locale, { weekday: "short", timeZone });
  const narrowFormat = new DateFormatter3(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}

// src/get-week-days.ts
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}

// src/get-year-range.ts
function getYearsRange(range) {
  const years = [];
  for (let year = range.from; year <= range.to; year += 1) {
    years.push(year);
  }
  return years;
}

// src/mutation.ts
import {
  getLocalTimeZone,
  toCalendar,
  toCalendarDateTime as toCalendarDateTime2,
  today as today3
} from "@internationalized/date";
function getTodayDate(timeZone) {
  return today3(timeZone ?? getLocalTimeZone());
}
function getNextDay(date) {
  return date.add({ days: 1 });
}
function getPreviousDay(date) {
  return date.subtract({ days: 1 });
}
function setMonth(date, month) {
  return date.set({ month });
}
function setYear(date, year) {
  return date.set({ year });
}
function setCalendar(date, calendar) {
  return toCalendar(toCalendarDateTime2(date), calendar);
}
function setDate(date, startDate, isDateUnavailable2, locale, minValue, maxValue) {
  let result;
  result = constrainValue(date, minValue, maxValue);
  result = getPreviousAvailableDate(date, startDate, locale, isDateUnavailable2);
  return result;
}
function getPreviousAvailableDate(date, minValue, locale, isDateUnavailable2) {
  if (!isDateUnavailable2) {
    return date;
  }
  while (date.compare(minValue) >= 0 && isDateUnavailable2(date, locale)) {
    date = date.subtract({ days: 1 });
  }
  if (date.compare(minValue) >= 0) {
    return date;
  }
}

// src/pagination.ts
import {
  endOfMonth as endOfMonth2,
  endOfWeek,
  startOfMonth as startOfMonth4,
  startOfWeek as startOfWeek2
} from "@internationalized/date";
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue),
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  let start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getNextRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ weeks: 1 }),
      startDate
    });
  }
}
function getPreviousRow(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks || visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ weeks: 1 }),
      startDate
    });
  }
}
function getSectionStart(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: startDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: startOfWeek2(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: startOfMonth4(focusedDate),
      startDate
    });
  }
}
function getSectionEnd(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const endDate = getEndDate(startDate, visibleDuration);
  if (visibleDuration.days) {
    return adjust({
      focusedDate: endDate,
      startDate
    });
  }
  if (visibleDuration.weeks) {
    return adjust({
      //@ts-expect-error - endOfWeek is loosely typed
      focusedDate: endOfWeek(focusedDate, locale),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: endOfMonth2(focusedDate),
      startDate
    });
  }
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}

// src/parse-date.ts
import { CalendarDate, DateFormatter as DateFormatter4 } from "@internationalized/date";
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new CalendarDate(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new CalendarDate(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new DateFormatter4(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g)?.map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)?.[1];
  }).reduce((acc, curr, index) => {
    if (!curr) return acc;
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}

// src/preset.ts
import {
  endOfMonth as endOfMonth3,
  endOfWeek as endOfWeek2,
  endOfYear,
  now,
  startOfMonth as startOfMonth5,
  startOfWeek as startOfWeek3,
  startOfYear as startOfYear2
} from "@internationalized/date";
function getDateRangePreset(preset, locale, timeZone) {
  const today4 = now(timeZone);
  switch (preset) {
    case "thisWeek":
      return [startOfWeek3(today4, locale), endOfWeek2(today4, locale)];
    case "thisMonth":
      return [startOfMonth5(today4), today4];
    case "thisQuarter":
      return [startOfMonth5(today4).add({ months: -today4.month % 3 }), today4];
    case "thisYear":
      return [startOfYear2(today4), today4];
    case "last3Days":
      return [today4.add({ days: -2 }), today4];
    case "last7Days":
      return [today4.add({ days: -6 }), today4];
    case "last14Days":
      return [today4.add({ days: -13 }), today4];
    case "last30Days":
      return [today4.add({ days: -29 }), today4];
    case "last90Days":
      return [today4.add({ days: -89 }), today4];
    case "lastMonth":
      return [startOfMonth5(today4.add({ months: -1 })), endOfMonth3(today4.add({ months: -1 }))];
    case "lastQuarter":
      return [
        startOfMonth5(today4.add({ months: -today4.month % 3 - 3 })),
        endOfMonth3(today4.add({ months: -today4.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [startOfWeek3(today4, locale).add({ weeks: -1 }), endOfWeek2(today4, locale).add({ weeks: -1 })];
    case "lastYear":
      return [startOfYear2(today4.add({ years: -1 })), endOfYear(today4.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}
export {
  alignCenter,
  alignDate,
  alignEnd,
  alignStart,
  alignStartDate,
  constrainStart,
  constrainValue,
  formatRange,
  formatSelectedDate,
  formatVisibleRange,
  getAdjustedDateFn,
  getCustomWeeksInMonth,
  getDateRangePreset,
  getDayFormatter,
  getDaysInWeek,
  getDecadeRange,
  getEndDate,
  getMonthDays,
  getMonthFormatter,
  getMonthNames,
  getNextDay,
  getNextPage,
  getNextRow,
  getNextSection,
  getPreviousAvailableDate,
  getPreviousDay,
  getPreviousPage,
  getPreviousRow,
  getPreviousSection,
  getSectionEnd,
  getSectionStart,
  getTodayDate,
  getUnitDuration,
  getWeekDays,
  getWeekdayFormats,
  getYearsRange,
  isDateDisabled,
  isDateEqual,
  isDateInvalid,
  isDateOutsideVisibleRange,
  isDateUnavailable,
  isNextVisibleRangeInvalid,
  isPreviousVisibleRangeInvalid,
  isTodayDate,
  parseDateString,
  setCalendar,
  setDate,
  setMonth,
  setYear
};
//# sourceMappingURL=index.mjs.map