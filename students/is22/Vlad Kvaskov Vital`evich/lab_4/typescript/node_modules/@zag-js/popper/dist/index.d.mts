import { Placement, Boundary, AutoUpdateOptions, ComputePositionReturn, VirtualElement } from '@floating-ui/dom';
export { AutoUpdateOptions, Boundary, ComputePositionReturn, Placement } from '@floating-ui/dom';

type MaybeRectElement = HTMLElement | VirtualElement | null;
type MaybeElement = HTMLElement | null;
type MaybeFn<T> = T | (() => T);
type PlacementSide = "top" | "right" | "bottom" | "left";
type PlacementAlign = "start" | "center" | "end";
interface AnchorRect {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
}
interface PositioningOptions {
    /**
     * The strategy to use for positioning
     */
    strategy?: "absolute" | "fixed";
    /**
     * The initial placement of the floating element
     */
    placement?: Placement;
    /**
     * The offset of the floating element
     */
    offset?: {
        mainAxis?: number;
        crossAxis?: number;
    };
    /**
     * The main axis offset or gap between the reference and floating elements
     */
    gutter?: number;
    /**
     * The secondary axis offset or gap between the reference and floating elements
     */
    shift?: number;
    /**
     * The virtual padding around the viewport edges to check for overflow
     */
    overflowPadding?: number;
    /**
     * The minimum padding between the arrow and the floating element's corner.
     * @default 4
     */
    arrowPadding?: number;
    /**
     * Whether to flip the placement
     */
    flip?: boolean | Placement[];
    /**
     * Whether the popover should slide when it overflows.
     */
    slide?: boolean;
    /**
     * Whether the floating element can overlap the reference element
     * @default false
     */
    overlap?: boolean;
    /**
     * Whether to make the floating element same width as the reference element
     */
    sameWidth?: boolean;
    /**
     * Whether the popover should fit the viewport.
     */
    fitViewport?: boolean;
    /**
     * The overflow boundary of the reference element
     */
    boundary?: Boundary | (() => Boundary);
    /**
     * Options to activate auto-update listeners
     */
    listeners?: boolean | AutoUpdateOptions;
    /**
     * Function called when the placement is computed
     */
    onComplete?(data: ComputePositionReturn): void;
    /**
     * Function called when the floating element is positioned or not
     */
    onPositioned?(data: {
        placed: boolean;
    }): void;
    /**
     *  Function that returns the anchor rect
     */
    getAnchorRect?: (element: HTMLElement | VirtualElement | null) => AnchorRect | null;
    /**
     * A callback that will be called when the popover needs to calculate its
     * position.
     */
    updatePosition?: (data: {
        updatePosition: () => Promise<void>;
    }) => void | Promise<void>;
}

declare function getPlacement(referenceOrFn: MaybeFn<MaybeRectElement>, floatingOrFn: MaybeFn<MaybeElement>, opts?: PositioningOptions & {
    defer?: boolean;
}): () => void;

interface GetPlacementStylesOptions {
    placement?: Placement;
}
declare function getPlacementStyles(options?: Pick<PositioningOptions, "placement" | "sameWidth" | "fitViewport" | "strategy">): {
    arrow: {
        readonly [x: string]: string;
        readonly position: "absolute";
        readonly width: string;
        readonly height: string;
    };
    arrowTip: {
        readonly transform: any;
        readonly background: string;
        readonly top: "0";
        readonly left: "0";
        readonly width: "100%";
        readonly height: "100%";
        readonly position: "absolute";
        readonly zIndex: "inherit";
    };
    floating: {
        readonly position: "fixed" | "absolute";
        readonly isolation: "isolate";
        readonly minWidth: "max-content" | undefined;
        readonly width: "var(--reference-width)" | undefined;
        readonly maxWidth: "var(--available-width)" | undefined;
        readonly maxHeight: "var(--available-height)" | undefined;
        readonly top: "0px";
        readonly left: "0px";
        readonly transform: "translate3d(var(--x), var(--y), 0)" | "translate3d(0, -100vh, 0)";
        readonly zIndex: "var(--z-index)";
    };
};

declare function isValidPlacement(v: string): v is Placement;
declare function getPlacementSide(placement: Placement): PlacementSide;

export { type AnchorRect, type GetPlacementStylesOptions, type PlacementAlign, type PlacementSide, type PositioningOptions, getPlacement, getPlacementSide, getPlacementStyles, isValidPlacement };
