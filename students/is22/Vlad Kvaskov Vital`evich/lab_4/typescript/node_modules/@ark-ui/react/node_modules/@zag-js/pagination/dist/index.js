'use strict';

var anatomy$1 = require('@zag-js/anatomy');
var domQuery = require('@zag-js/dom-query');
var core = require('@zag-js/core');
var utils = require('@zag-js/utils');
var types = require('@zag-js/types');

// src/pagination.anatomy.ts
var anatomy = anatomy$1.createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts = anatomy.build();
var dom = domQuery.createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `pagination:${ctx.id}`,
  getPrevTriggerId: (ctx) => ctx.ids?.prevTrigger ?? `pagination:${ctx.id}:prev`,
  getNextTriggerId: (ctx) => ctx.ids?.nextTrigger ?? `pagination:${ctx.id}:next`,
  getEllipsisId: (ctx, index) => ctx.ids?.ellipsis?.(index) ?? `pagination:${ctx.id}:ellipsis:${index}`,
  getItemId: (ctx, page) => ctx.ids?.item?.(page) ?? `pagination:${ctx.id}:item:${page}`
});

// src/pagination.utils.ts
var range = (start, end) => {
  let length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number") return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));

// src/pagination.connect.ts
function connect(state, send, normalize) {
  const totalPages = state.context.totalPages;
  const page = state.context.page;
  const translations = state.context.translations;
  const count = state.context.count;
  const previousPage = state.context.previousPage;
  const nextPage = state.context.nextPage;
  const pageRange = state.context.pageRange;
  const type = state.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  const pages = getTransformedRange(state.context);
  return {
    count,
    page,
    pageSize: state.context.pageSize,
    totalPages,
    pages,
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count2) {
      send({ type: "SET_COUNT", count: count2 });
    },
    setPageSize(size) {
      send({ type: "SET_PAGE_SIZE", size });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    goToNextPage() {
      send({ type: "NEXT_PAGE" });
    },
    goToPrevPage() {
      send({ type: "PREVIOUS_PAGE" });
    },
    goToFirstPage() {
      send({ type: "FIRST_PAGE" });
    },
    goToLastPage() {
      send({ type: "LAST_PAGE" });
    },
    getRootProps() {
      return normalize.element({
        id: dom.getRootId(state.context),
        ...parts.root.attrs,
        dir: state.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props2) {
      return normalize.element({
        id: dom.getEllipsisId(state.context, props2.index),
        ...parts.ellipsis.attrs,
        dir: state.context.dir
      });
    },
    getItemProps(props2) {
      const index = props2.value;
      const isCurrentPage = index === state.context.page;
      return normalize.element({
        id: dom.getItemId(state.context, index),
        ...parts.item.attrs,
        dir: state.context.dir,
        "data-index": index,
        "data-selected": domQuery.dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": translations.itemLabel?.({ page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize.element({
        id: dom.getPrevTriggerId(state.context),
        ...parts.prevTrigger.attrs,
        dir: state.context.dir,
        "data-disabled": domQuery.dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize.element({
        id: dom.getNextTriggerId(state.context),
        ...parts.nextTrigger.attrs,
        dir: state.context.dir,
        "data-disabled": domQuery.dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
var defaultTranslations = {
  rootLabel: "pagination",
  prevTriggerLabel: "previous page",
  nextTriggerLabel: "next page",
  itemLabel({ page, totalPages }) {
    const isLastPage = totalPages > 1 && page === totalPages;
    return `${isLastPage ? "last page, " : ""}page ${page}`;
  }
};
function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          ...defaultTranslations,
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = start + ctx2.pageSize;
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        FIRST_PAGE: {
          actions: "goToFirstPage"
        },
        LAST_PAGE: {
          actions: "goToLastPage"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set.page(ctx2, 1);
        },
        goToLastPage(ctx2) {
          set.page(ctx2, ctx2.totalPages);
        },
        goToPrevPage(ctx2) {
          set.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage) return;
          set.page(ctx2, 1);
        }
      }
    }
  );
}
var clampPage = (page, totalPages) => Math.min(Math.max(page, 1), totalPages);
var set = {
  pageSize: (ctx, value) => {
    if (utils.isEqual(ctx.pageSize, value)) return;
    ctx.pageSize = value;
    ctx.onPageSizeChange?.({ pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    if (utils.isEqual(ctx.page, value)) return;
    ctx.page = clampPage(value, ctx.totalPages);
    ctx.onPageChange?.({ page: ctx.page, pageSize: ctx.pageSize });
  }
};
var props = types.createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps = utils.createSplitProps(props);
var itemProps = types.createProps()(["value", "type"]);
var splitItemProps = utils.createSplitProps(itemProps);
var ellipsisProps = types.createProps()(["index"]);
var splitEllipsisProps = utils.createSplitProps(ellipsisProps);

exports.anatomy = anatomy;
exports.connect = connect;
exports.ellipsisProps = ellipsisProps;
exports.itemProps = itemProps;
exports.machine = machine;
exports.props = props;
exports.splitEllipsisProps = splitEllipsisProps;
exports.splitItemProps = splitItemProps;
exports.splitProps = splitProps;
