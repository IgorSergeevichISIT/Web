'use strict';

var anatomy$1 = require('@zag-js/anatomy');
var domQuery = require('@zag-js/dom-query');
var focusVisible = require('@zag-js/focus-visible');
var core = require('@zag-js/core');
var elementRect = require('@zag-js/element-rect');
var formUtils = require('@zag-js/form-utils');
var utils = require('@zag-js/utils');
var types = require('@zag-js/types');

// src/radio-group.anatomy.ts
var anatomy = anatomy$1.createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts = anatomy.build();
var dom = domQuery.createScope({
  getRootId: (ctx) => ctx.ids?.root ?? `radio-group:${ctx.id}`,
  getLabelId: (ctx) => ctx.ids?.label ?? `radio-group:${ctx.id}:label`,
  getItemId: (ctx, value) => ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,
  getItemHiddenInputId: (ctx, value) => ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,
  getItemControlId: (ctx, value) => ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,
  getItemLabelId: (ctx, value) => ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,
  getIndicatorId: (ctx) => ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`,
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom.getById(ctx, dom.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom.getById(ctx, dom.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled)"),
  getFirstEnabledAndCheckedInputEl: (ctx) => dom.getRootEl(ctx)?.querySelector("input:not(:disabled):checked"),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return domQuery.queryAll(dom.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value) return;
    return dom.getById(ctx, dom.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: el?.offsetLeft ?? 0,
    top: el?.offsetTop ?? 0,
    width: el?.offsetWidth ?? 0,
    height: el?.offsetHeight ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom.getById(ctx, dom.getItemId(ctx, id));
    if (!radioEl) return;
    return dom.resolveRect(dom.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});

// src/radio-group.connect.ts
function connect(state, send, normalize) {
  const groupDisabled = state.context.isDisabled;
  const readOnly = state.context.readOnly;
  function getItemState(props2) {
    return {
      invalid: !!props2.invalid,
      disabled: !!props2.disabled || groupDisabled,
      checked: state.context.value === props2.value,
      focused: state.context.focusedValue === props2.value,
      hovered: state.context.hoveredValue === props2.value,
      active: state.context.activeValue === props2.value
    };
  }
  function getItemDataAttrs(props2) {
    const radioState = getItemState(props2);
    return {
      "data-focus": domQuery.dataAttr(radioState.focused),
      "data-focus-visible": domQuery.dataAttr(radioState.focused && state.context.focusVisible),
      "data-disabled": domQuery.dataAttr(radioState.disabled),
      "data-readonly": domQuery.dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": domQuery.dataAttr(radioState.hovered),
      "data-invalid": domQuery.dataAttr(radioState.invalid),
      "data-orientation": state.context.orientation,
      "data-ssr": domQuery.dataAttr(state.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom.getFirstEnabledAndCheckedInputEl(state.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom.getFirstEnabledInputEl(state.context);
    firstEnabledInput?.focus();
  };
  return {
    focus,
    value: state.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        role: "radiogroup",
        id: dom.getRootId(state.context),
        "aria-labelledby": dom.getLabelId(state.context),
        "data-orientation": state.context.orientation,
        "data-disabled": domQuery.dataAttr(groupDisabled),
        "aria-orientation": state.context.orientation,
        dir: state.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        dir: state.context.dir,
        "data-orientation": state.context.orientation,
        "data-disabled": domQuery.dataAttr(groupDisabled),
        id: dom.getLabelId(state.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props2) {
      const itemState = getItemState(props2);
      return normalize.label({
        ...parts.item.attrs,
        dir: state.context.dir,
        id: dom.getItemId(state.context, props2.value),
        htmlFor: dom.getItemHiddenInputId(state.context, props2.value),
        ...getItemDataAttrs(props2),
        onPointerMove() {
          if (itemState.disabled) return;
          if (itemState.hovered) return;
          send({ type: "SET_HOVERED", value: props2.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled) return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled) return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props2.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled) return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props2) {
      return normalize.element({
        ...parts.itemText.attrs,
        dir: state.context.dir,
        id: dom.getItemLabelId(state.context, props2.value),
        ...getItemDataAttrs(props2)
      });
    },
    getItemControlProps(props2) {
      const controlState = getItemState(props2);
      return normalize.element({
        ...parts.itemControl.attrs,
        dir: state.context.dir,
        id: dom.getItemControlId(state.context, props2.value),
        "data-active": domQuery.dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props2)
      });
    },
    getItemHiddenInputProps(props2) {
      const inputState = getItemState(props2);
      return normalize.input({
        "data-ownedby": dom.getRootId(state.context),
        id: dom.getItemHiddenInputId(state.context, props2.value),
        type: "radio",
        name: state.context.name || state.context.id,
        form: state.context.form,
        value: props2.value,
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.currentTarget.checked) {
            send({ type: "SET_VALUE", value: props2.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null, focused: false, focusVisible: false });
        },
        onFocus() {
          const focusVisible$1 = focusVisible.isFocusVisible();
          send({ type: "SET_FOCUSED", value: props2.value, focused: true, focusVisible: focusVisible$1 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props2.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented) return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: domQuery.visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      return normalize.element({
        id: dom.getIndicatorId(state.context),
        ...parts.indicator.attrs,
        dir: state.context.dir,
        hidden: state.context.value == null,
        "data-disabled": domQuery.dataAttr(groupDisabled),
        "data-orientation": state.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": state.context.indicatorRect?.left,
          "--top": state.context.indicatorRect?.top,
          "--width": state.context.indicatorRect?.width,
          "--height": state.context.indicatorRect?.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state.context.orientation === "horizontal" ? "left" : "top"]: state.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not } = core.guards;
function machine(userContext) {
  const ctx = utils.compact(userContext);
  return core.createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        focusVisible: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState", "trackFocusVisible"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return formUtils.trackFormControl(dom.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        },
        trackFocusVisible(ctx2) {
          return focusVisible.trackFocusVisible({ root: dom.getRootNode(ctx2) });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
          ctx2.focusVisible = evt.focusVisible;
        },
        syncInputElements(ctx2) {
          const inputs = dom.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = utils.isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          ctx2.indicatorCleanup?.();
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          ctx2.indicatorCleanup?.();
          if (!dom.getIndicatorEl(ctx2)) return;
          const value = ctx2.value;
          const radioEl = dom.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = elementRect.trackElementRect(radioEl, {
            getRect(el) {
              return dom.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom.resolveRect(rect);
              domQuery.nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked) return;
            formUtils.dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke = {
  change: (ctx) => {
    if (ctx.value == null) return;
    ctx.onValueChange?.({ value: ctx.value });
  }
};
var set = {
  value: (ctx, value) => {
    if (utils.isEqual(ctx.value, value)) return;
    ctx.value = value;
    invoke.change(ctx);
  }
};
var props = types.createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps = utils.createSplitProps(props);
var itemProps = types.createProps()(["value", "disabled", "invalid"]);
var splitItemProps = utils.createSplitProps(itemProps);

exports.anatomy = anatomy;
exports.connect = connect;
exports.itemProps = itemProps;
exports.machine = machine;
exports.props = props;
exports.splitItemProps = splitItemProps;
exports.splitProps = splitProps;
