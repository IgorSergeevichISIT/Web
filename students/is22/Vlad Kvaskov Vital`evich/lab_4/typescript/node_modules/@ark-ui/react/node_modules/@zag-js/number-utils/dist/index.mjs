// src/number.ts
function wrap(num, max) {
  return (num % max + max) % max;
}
function round(num, t) {
  const p = 10 ** (t ?? 10);
  num = Math.round(num * p) / p;
  return t ? num.toFixed(t) : num.toString();
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number") return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
var valueToPercent = (v, r) => (nan(v) - r.min) * 100 / (r.max - r.min);
var percentToValue = (v, r) => r.min + (r.max - r.min) * nan(v);
function clamp(v, o) {
  return Math.min(Math.max(nan(v), o.min), o.max);
}
function countDecimals(value) {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
var increment = (v, s) => decimalOperation(nan(v), "+", s);
var decrement = (v, s) => decimalOperation(nan(v), "-", s);
function snapToStep(num, step) {
  const p = countDecimals(step);
  const v = Math.round(nan(num) / step) * step;
  return round(v, p);
}
function nan(v) {
  return Number.isNaN(v) ? 0 : v;
}
function formatDecimal(v, o) {
  return new Intl.NumberFormat("en-US", {
    useGrouping: false,
    style: "decimal",
    minimumFractionDigits: o.minFractionDigits,
    maximumFractionDigits: o.maxFractionDigits
  }).format(nan(v));
}
function isAtMax(val, o) {
  return nan(val) >= o.max;
}
function isAtMin(val, o) {
  return nan(val) <= o.min;
}
function isWithinRange(val, o) {
  return nan(val) >= o.min && nan(val) <= o.max;
}
function decimalOperation(a, op, b) {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
}

// src/number-format.ts
var nf = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });
function formatter(n) {
  return parseFloat(nf.format(n));
}

// src/transform.ts
var transform = (a, b) => {
  const i = { min: a[0], max: a[1] };
  const o = { min: b[0], max: b[1] };
  return (v) => {
    if (i.min === i.max || o.min === o.max) return o.min;
    const ratio = (o.max - o.min) / (i.max - i.min);
    return o.min + ratio * (v - i.min);
  };
};
function toRanges(o) {
  const spacing = o.spacing ?? 0;
  return o.value.map((v, i) => {
    const min = i === 0 ? o.min : o.value[i - 1] + spacing;
    const max = i === o.value.length - 1 ? o.max : o.value[i + 1] - spacing;
    return { min, max, value: v };
  });
}
function toRangeArray(o) {
  let i = o.min;
  const range = [];
  while (i <= o.max) {
    range.push(i);
    i = formatter(i + o.step);
  }
  return range;
}

export { clamp, countDecimals, decrement, formatDecimal, increment, isAtMax, isAtMin, isWithinRange, nan, percentToValue, round, roundToDevicePixel, snapToStep, toRangeArray, toRanges, transform, valueToPercent, wrap };
