"use strict";
"use client";
import { jsx } from 'react/jsx-runtime';
import { forwardRef } from 'react';
import { createContext } from '../create-context.js';
import { mergeProps } from '../merge-props.js';
import { cx } from '../utils/cx.js';
import { EMPTY_STYLES } from './empty.js';
import { chakra } from './factory.js';
import { useRecipe } from './use-recipe.js';

const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
function createRecipeContext(options) {
  const { key: recipeKey, recipe: recipeConfig } = options;
  const contextName = upperFirst(
    recipeKey || recipeConfig.className || "Component"
  );
  const [PropsProvider, usePropsContext] = createContext({
    strict: false,
    name: `${contextName}PropsContext`,
    providerName: `${contextName}PropsContext`
  });
  const withContext = (Component, options2) => {
    const SuperComponent = chakra(Component, {}, options2);
    const StyledComponent = forwardRef((inProps, ref) => {
      const props = mergeProps(usePropsContext(), inProps);
      const { unstyled, ...otherProps } = props;
      const fallbackRecipe = props.recipe || recipeConfig;
      const recipe = useRecipe({ key: recipeKey, recipe: fallbackRecipe });
      const [variantProps, localProps] = recipe.splitVariantProps(otherProps);
      const styles = unstyled ? EMPTY_STYLES : recipe(variantProps);
      return /* @__PURE__ */ jsx(
        SuperComponent,
        {
          ...localProps,
          ref,
          css: [styles, props.css],
          className: cx(recipe.className, props.className)
        }
      );
    });
    StyledComponent.displayName = Component.displayName || Component.name;
    return StyledComponent;
  };
  return {
    withContext,
    PropsProvider,
    usePropsContext
  };
}

export { createRecipeContext };
